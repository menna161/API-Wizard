import numpy as np


def generate_code(filename, ds_column, y, test_stationarity_code, test_set_size, seasonality, p, d, q, P, D, Q, s, exog_variables_names, transformation_function, periods_to_forecast, data_frequency):
    code_base = '\n                ```python\n\n                import matplotlib.pyplot as plt\n                import numpy as np\n                import os\n                import pandas as pd\n                import plotly.graph_objs as go\n                import statsmodels.api as sm\n\n                from math import sqrt\n                from plotly.offline import iplot, init_notebook_mode\n                from sklearn.metrics import mean_squared_error, mean_absolute_error\n                from statsmodels.tsa.seasonal import seasonal_decompose\n                from statsmodels.tsa.stattools import adfuller\n\n                # Granting that pandas will not use scientific notation for floating fields\n                pd.set_option(\'display.float_format\', lambda x: \'%.3f\' % x) \n\n                # Using Matplotlib figures inline\n                %matplotlib inline\n\n                # Setting Plot.ly to work on notebooks\n                init_notebook_mode(connected=True)\n\n                # Defining some functions\n                def mean_abs_pct_error(actual_values, forecast_values):\n                    \'\'\'\n                    MAPE function to understand the average error percentage of the model\n\n                    Args.:\n                        actual_values (Numpy 1D Array, List or Iterable): True values of the set\n                        forecast_values (Numpy 1D Array, List or Iterable): Values predicted by the model\n                    Return:\n                        MAPE value (float)\n                    \'\'\'\n                    err=0\n                    for i in range(len(forecast_values)):\n                        err += np.abs(actual_values.values[i] - forecast_values.values[i]) / actual_values.values[i]\n                    return err * 100/len(forecast_values)\n\n                def decompose_series(ts):\n                    \'\'\'\n                    This function applies a seasonal decomposition to a time series. It will generate a season plot, a trending plot, and, finally, a resid plot\n\n                    Args.\n                        ts (Pandas Series): a time series to be decomposed\n                    \'\'\'\n                    fig = plt.Figure(figsize=(12,7))\n                    ax1 = plt.subplot(311)\n                    ax2 = plt.subplot(312)\n                    ax3 = plt.subplot(313)\n\n                    decomposition = seasonal_decompose(ts)\n\n                    decomposition.seasonal.plot(ax=ax1, title=\'Seasonality\')\n                    plt.legend(\'\')\n\n                    decomposition.trend.plot(ax=ax2, title=\'Trending\')\n                    plt.legend(\'\')\n                    \n                    decomposition.resid.plot(ax=ax3, title=\'Resid\')\n                    plt.legend(\'\')\n\n                    plt.subplots_adjust(hspace=1)\n                    plt.show()\n\n                def find_acf_pacf(timeseries, seasonality):\n                    \'\'\'\n                    Function to find the amount of terms for p and q\n                    Args.\n                        timeseries (Pandas Series): a time series to estimate the p and q terms\n                        seasonality (int): the seasonality is used to estimate the amount of lags to consider. By default, this function will use seasonality * 2 lags\n                            to compute ACF and PACF\n                    \'\'\'\n                    \n                    fig = plt.Figure(figsize=(12,7))\n                    ax1 = plt.subplot(211)\n                    ax2 = plt.subplot(212)\n\n                    # Ploting the ACF function\n                    sm.graphics.tsa.plot_acf(timeseries.dropna(), lags = seasonality * 2, ax=ax1)\n                    \n                    # Ploting the PACF function\n                    sm.graphics.tsa.plot_pacf(timeseries.dropna(), lags = seasonality * 2, ax=ax2)\n                    \n                    plt.subplots_adjust(hspace=.4)\n                    plt.show()\n                \n                def predict_set(timeseries, y, seasonality, transformation_function, model, forecast=False):\n                    \'\'\'\n                    Predicts the in-sample train observations\n\n                    Args.\n                        timeseries (Pandas Series): a time series that was used to fit a model\n                        y (str): the target column\n                        seasonality (int): the seasonality frequency\n                        transformation_function (func): a function used to transform the target values\n                        model (Statsmodel object): a fitted model\n                        forecast (bool): wether or not forecast the test set\n                    \'\'\'\n                    timeseries = timeseries.to_frame()\n                    timeseries[y] = transformation_function(timeseries[y])\n\n                    if forecast:\n                        timeseries[\'ŷ\'] = transformation_function(model.forecast(len(timeseries)))\n                    else:\n                        timeseries[\'ŷ\'] = transformation_function(model.predict())\n                    \n                    timeseries[[y, \'ŷ\']].iloc[-(seasonality*3):].plot()\n\n                    plt.ylabel(y)\n                    plt.xlabel(\'\')\n                    plt.title(\'Train set predictions\')\n                    plt.show()\n\n                    rmse = sqrt(mean_squared_error(timeseries[y].iloc[-(seasonality*3):], \n                                                   timeseries[\'ŷ\'].iloc[-(seasonality*3):]))\n                    aic = model.aic\n                    bic = model.bic\n                    hqic = model.hqic\n                    mape = np.round(mean_abs_pct_error(timeseries[y].iloc[-(seasonality*3):], \n                                    timeseries[\'ŷ\'].iloc[-(seasonality*3):]), 2)\n                    mae = np.round(mean_absolute_error(timeseries[y].iloc[-(seasonality*3):], \n                                   timeseries[\'ŷ\'].iloc[-(seasonality*3):]), 2)\n                    \n                    metrics_df = pd.DataFrame(data=[rmse, aic, bic, hqic, mape, mae], \n                                              columns = [\'DATASET METRICS\'], \n                                              index = [\'RMSE\', \'AIC\', \'BIC\', \'HQIC\', \'MAPE\', \'MAE\'])\n                    print(metrics_df)\n\n                def grid_search(train_data, exog,  p_range, q_range, P_range, Q_range, d=1, D=1, s=12):\n                    \'\'\'\n                    Grid search for SARIMAX models. This is a time consuming function that will iterate\n                    over different terms for AR and MA.\n\n                    Args:\n                        train_data (Pandas Series, Numpy Array, iterable): the training data containing endog variables\n                        exog (Pandas Series, Numpy Array, iterable): exogenous variables\n                        p_range (iterable): range of terms for p\n                        d_range (int): differencing terms\n                        q_range (iterable): range of terms for q\n                        P_range (iterable): range of terms for Q\n                        D_range (int): seasonal differencing terms\n                        Q_range (iterable): range of terms for Q\n                        s (int): seasonal frequency\n                    Return:\n                        current_best_model (Statsmodels SARIMAX results): a model with the best parameters, \n                            based on AIC, BIC, and HQIC metrics\n                        models (list): all past models metrics for each iteractions\n                    \'\'\'\n                    best_model_aic = np.Inf \n                    best_model_bic = np.Inf \n                    best_model_hqic = np.Inf\n                    best_model_order = (0, 0, 0)\n                    models = []\n\n                    for p_ in p_range:\n                        for q_ in q_range:\n                            for P_ in P_range:\n                                for Q_ in Q_range:\n                                    try:\n                                        no_of_lower_metrics = 0\n                                        model = sm.tsa.statespace.SARIMAX(endog = train_data,\n                                                                        order = (p_, d, q_),\n                                                                        exog = exog,\n                                                                        seasonal_order = (P_, D, Q_, s),\n                                                                        enforce_invertibility=False).fit()\n                                        models.append(model)\n                                        if model.aic <= best_model_aic: no_of_lower_metrics += 1\n                                        if model.bic <= best_model_bic: no_of_lower_metrics += 1\n                                        if model.hqic <= best_model_hqic:no_of_lower_metrics += 1\n                                        if no_of_lower_metrics >= 2:\n                                            best_model_aic = np.round(model.aic,0)\n                                            best_model_bic = np.round(model.bic,0)\n                                            best_model_hqic = np.round(model.hqic,0)\n                                            best_model_order = (p_,d,q_,P_,D,Q_,s)\n                                            current_best_model = model\n                                            models.append(model)\n                                            print("Best model so far: SARIMA" + str(best_model_order) + \n                                                "AIC: {{}} BIC: {{}} HQIC: {{}}".format(best_model_aic,best_model_bic,best_model_hqic)+\n                                                "Resid: {{}}".format(np.round(np.expm1(current_best_model.resid).mean(), 3)))\n                                    except:\n                                        pass\n\n                    print(\'\\n\')\n                    print(current_best_model.summary())                \n                    return current_best_model, models\n\n                def plot_forecasts(forecasts, confidence_interval, periods):\n                    \'\'\'\n                    Generate a plot with the forecasted observations\n\n                    Args.\n                        forecasts (Pandas Series): out-of-sample observations\n                        confidence_interval (Pandas DataFrame): DataFrame containing a column for the lower boundary and another for the upper boundary \n                        periods (int): how much periods to forecast?\n                    \'\'\'\n                    lower_ci = dict(x = confidence_interval.index, \n                                    y = confidence_interval[\'ci_lower\'], \n                                    line = dict(\n                                            color = \'#1EBC61\', \n                                            shape = \'linear\',\n                                            width = 0.1\n                                                ), \n                                    mode = \'lines\',\n                                    name = \'Lower 95% CI\', \n                                    showlegend = False, \n                                    type = "scatter", \n                                    xaxis = \'x\', \n                                    yaxis = \'y\')\n                    upper_ci = dict(x = confidence_interval.index, \n                                    y = confidence_interval[\'ci_upper\'], \n                                    fill = \'tonexty\', \n                                    line = dict(\n                                            color = \'#1EBC61\', \n                                            shape = \'linear\',\n                                            width = 0.1\n                                                ), \n                                    mode = \'lines\', \n                                    name = \'Upper 95% CI\', \n                                    type = \'scatter\', \n                                    xaxis = \'x\', \n                                    yaxis = \'y\')\n                    forecasting =  dict(x = forecasts.index, \n                                        y = forecasts.values,\n                                        line = dict(\n                                                color = \'#005C01\', \n                                                shape = \'linear\',\n                                                width = 3\n                                                ), \n                                    mode = \'lines\', \n                                    name = \'Forecasting\', \n                                    type = \'scatter\', \n                                    xaxis = \'x\', \n                                    yaxis = \'y\')\n\n                    plot_data = ([lower_ci, upper_ci, forecasting])\n                    layout = go.Layout(title = str(periods) + \' Forecasts\')\n                    fig = go.Figure(data = plot_data, layout=layout)\n                    iplot(fig)\n                \n                # Reading dataset\n                df = pd.read_csv(\'{0}\')\n                '.format(filename)
    transform_time_series = "\n                # Reading dataset\n                df.set_index('{}', inplace = True)\n                df.index = df.index.astype('datetime64[ns]')\n                print(df.head())\n\n                # Plotting your historical data\n                df.plot(color='green')\n                plt.title('Absolute historical data')\n                plt.show()\n\n                # Creating exogenous variables\n                exogenous_variables = {}\n\n                # Transforming data to a series\n                df = df['{}']            \n                            ".format(ds_column, ('df[{}]'.format(exog_variables_names) if (len(exog_variables_names) > 0) else None), y)
    test_stationarity = test_stationarity_code
    rolling_statistics = "\n                # Checking rolling statistics\n                mean = df.rolling(window={0}).mean()\n                std = df.rolling(window={0}).std()\n\n                # Plotting rolling statistics\n                fig = plt.figure(figsize=(10, 5))\n                orig = plt.plot(df, color='green', label='Original')\n                mean = plt.plot(mean, color='red', label='Mean')\n                std = plt.plot(std, color='black', label='Std')\n\n                plt.legend(loc='best')\n                plt.title(f'Moving average and Standard Deviation')\n                plt.show()\n                            ".format(seasonality)
    dickey_fuller_test = "\n                # Performing Dickey-Fuller test\n                print('Best ADF Test Results')\n                critical_value_1_perc = dftest[4]['1%']\n\n                dfoutput = pd.Series(dftest[0:4], index=['Statistical Test', 'p-value', '#Lags used', 'Number of observations'])\n                for key, value in dftest[4].items():\n                    dfoutput['Critical value ' + key] = value\n                print(dfoutput)\n                         "
    preprocessing_code = '\n                train_transformation_func = {0}\n                train_set = train_transformation_func(df.iloc[:-{1}])\n                test_set = train_transformation_func(df.iloc[-{1}:])\n                         '.format(('np.log1p' if (transformation_function == np.log1p) else 'lambda x: x'), test_set_size)
    train_model = f'''
                # Training model
                mod = sm.tsa.statespace.SARIMAX(df,
                                                order = ({p}, {d}, {q}),
                                                exog = exogenous_variables,
                                                seasonal_order = ({P}, {D}, {Q}, {s}),
                                                enforce_invertibility=False)
                # Fitting model
                try:
                    mod = mod.fit()
                except np.linalg.LinAlgError:
                    mod = sm.tsa.statespace.SARIMAX(df,
                                                order = ({p}, {d}, {q}),
                                                exog = exogenous_variables,
                                                seasonal_order = ({P}, {D}, {Q}, {s}),
                                                enforce_invertibility=False,
                                                initialization='approximate_diffuse')
                    mod = mod.fit()
                print(mod.summary())

                ## Uncomment this part to use Grid Search (computational expensive)
                #grid_search(df, exogenous_variables, range({(p + 3)}), {d}, range({(q + 3)}), range({(P + 3)}), {D}, range({(Q + 3)}), {s})
                  '''.format(p, d, q, P, D, Q, s)
    predict_set = "\n                predict_set(df, '{}', {}, {}, mod)\n                  ".format(y, seasonality, ('np.log1p' if (transformation_function == np.log1p) else 'lambda x: x'))
    forecasting_code = "\n                # Forecasting out-of-sample periods\n                forecasts = np.expm1(mod.forecast({0}))\n                confidence_interval = np.expm1(mod.get_forecast({0}).conf_int())\n                \n                # Generating confidence interval and plotting forecasting\n                confidence_interval.columns = ['ci_lower', 'ci_upper']\n                plot_forecasts(forecasts, confidence_interval, '{1}')\n                        ".format(periods_to_forecast, data_frequency)
    final_code = ((((((((code_base + transform_time_series) + test_stationarity) + rolling_statistics) + dickey_fuller_test) + preprocessing_code) + train_model) + predict_set) + forecasting_code)
    return final_code
