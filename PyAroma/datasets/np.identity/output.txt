------------------------- example 1 ------------------------ 
def test_left_jacobians():
    phi_small = 0.0
    phi_big = (np.pi / 2)
    left_jacobian_small = SO2.left_jacobian(phi_small)
// your code ...
    assert np.allclose(left_jacobian_small.dot(inv_left_jacobian_small), np.identity(2))
    left_jacobian_big = SO2.left_jacobian(phi_big)
// your code ...
    assert np.allclose(left_jacobian_big.dot(inv_left_jacobian_big), np.identity(2))

------------------------- example 2 ------------------------ 
def test_left_jacobian():
    xi1 = [1, 2, 3, 4, 5, 6]
    assert np.allclose(SE3.left_jacobian(xi1).dot(SE3.inv_left_jacobian(xi1)), np.identity(6))
    xi2 = [0, 0, 0, 0, 0, 0]
    assert np.allclose(SE3.left_jacobian(xi2).dot(SE3.inv_left_jacobian(xi2)), np.identity(6))

------------------------- example 3 ------------------------ 
def test_inv():
    C = SO2.exp((np.pi / 4))
    assert np.allclose(C.dot(C.inv()).mat, np.identity(2))

------------------------- example 4 ------------------------ 
def test_zca_whitening():
    X = np.random.uniform((- 10), 10, (100, 3))
// your code ...
    C = np.cov(Y, rowvar=False)
    assert np.isclose(C, np.identity(3)).all()
    assert_array_almost_equal(np.mean(Y, axis=0), np.zeros(3))

------------------------- example 5 ------------------------ 
def update_weights(robustifier, x_true, x_pred, weights):
    E = calc_errors(x_true, x_pred, weights)
    I = np.identity(2)
    return np.array([(I * w) for w in robustifier.weights(E)])

examples  ||  representativeness  ||  number of lines  || number of comments   ||  relevancy  
example1  ||          3           ||        7         ||         2        ||        0.2857142857142857         
example2  ||          5           ||        5         ||         0        ||        0.4         
example3  ||          2           ||        3         ||         0        ||        0.3333333333333333         
example4  ||          2           ||        5         ||         1        ||        0.2         
example5  ||          2           ||        4         ||         0        ||        0.25         

avg       ||          5.833333333333333           ||        4.8         ||         0.6        ||         29.38095238095238        

idx = 0:------------------- similar code ------------------ index = 0, score = 6.0 
def test_left_jacobians():
    phi_small = 0.0
    phi_big = (np.pi / 2)
    left_jacobian_small = SO2.left_jacobian(phi_small)
    inv_left_jacobian_small = SO2.inv_left_jacobian(phi_small)
    assert np.allclose(left_jacobian_small.dot(inv_left_jacobian_small), np.identity(2))
    left_jacobian_big = SO2.left_jacobian(phi_big)
    inv_left_jacobian_big = SO2.inv_left_jacobian(phi_big)
    assert np.allclose(left_jacobian_big.dot(inv_left_jacobian_big), np.identity(2))

------------------- similar code (pruned) ------------------ score = 0.5833333333333334 
def  ... ():
    assert np. ... (,  ... .identity)

idx = 1:------------------- similar code ------------------ index = 24, score = 6.0 
def test_left_jacobian():
    xi1 = [1, 2, 3, 4, 5, 6]
    assert np.allclose(SE3.left_jacobian(xi1).dot(SE3.inv_left_jacobian(xi1)), np.identity(6))
    xi2 = [0, 0, 0, 0, 0, 0]
    assert np.allclose(SE3.left_jacobian(xi2).dot(SE3.inv_left_jacobian(xi2)), np.identity(6))

------------------- similar code (pruned) ------------------ score = 0.5833333333333334 
def  ... ():
    assert np. ... (,  ... .identity)

idx = 2:------------------- similar code ------------------ index = 9, score = 6.0 
def test_inv():
    C = SO2.exp((np.pi / 4))
    assert np.allclose(C.dot(C.inv()).mat, np.identity(2))

------------------- similar code (pruned) ------------------ score = 0.5833333333333334 
def  ... ():
    assert np. ... (,  ... .identity)

idx = 3:------------------- similar code ------------------ index = 21, score = 6.0 
def test_left_jacobians():
    phi_small = [0.0, 0.0, 0.0]
    phi_big = [(np.pi / 2), (np.pi / 3), (np.pi / 4)]
    left_jacobian_small = SO3.left_jacobian(phi_small)
    inv_left_jacobian_small = SO3.inv_left_jacobian(phi_small)
    assert np.allclose(left_jacobian_small.dot(inv_left_jacobian_small), np.identity(3))
    left_jacobian_big = SO3.left_jacobian(phi_big)
    inv_left_jacobian_big = SO3.inv_left_jacobian(phi_big)
    assert np.allclose(left_jacobian_big.dot(inv_left_jacobian_big), np.identity(3))

------------------- similar code (pruned) ------------------ score = 0.5833333333333334 
def  ... ():
    assert np. ... (,  ... .identity)

idx = 4:------------------- similar code ------------------ index = 22, score = 6.0 
def test_inv():
    T = SE3.exp([1, 2, 3, 4, 5, 6])
    assert np.allclose(T.dot(T.inv()).as_matrix(), np.identity(4))

------------------- similar code (pruned) ------------------ score = 0.5833333333333334 
def  ... ():
    assert np. ... (,  ... .identity)

idx = 5:------------------- similar code ------------------ index = 26, score = 6.0 
def test_inv():
    T = SE2.exp([1, 2, 3])
    assert np.allclose(T.dot(T.inv()).as_matrix(), np.identity(3))

------------------- similar code (pruned) ------------------ score = 0.5833333333333334 
def  ... ():
    assert np. ... (,  ... .identity)

idx = 6:------------------- similar code ------------------ index = 1, score = 6.0 
def test_inv():
    C = SO3.exp(((np.pi * np.ones(3)) / 4))
    assert np.allclose(C.dot(C.inv()).mat, np.identity(3))

------------------- similar code (pruned) ------------------ score = 0.5833333333333334 
def  ... ():
    assert np. ... (,  ... .identity)

idx = 7:------------------- similar code ------------------ index = 16, score = 6.0 
@classmethod
def identity(cls):
    'Return the identity transformation.'
    return cls.from_matrix(np.identity(cls.dim))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def identity( ... ):
    return  ... . ... (np)

idx = 8:------------------- similar code ------------------ index = 4, score = 6.0 
def test_zca_whitening():
    X = np.random.uniform((- 10), 10, (100, 3))
    X = normalize_mean(X)
    Y = zca_whitening(X)
    C = np.cov(Y, rowvar=False)
    assert np.isclose(C, np.identity(3)).all()
    assert_array_almost_equal(np.mean(Y, axis=0), np.zeros(3))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    assert  ... . ... ( ... , np.identity)

idx = 9:------------------- similar code ------------------ index = 23, score = 6.0 
@classmethod
def identity(cls):
    'Return the identity rotation.'
    return cls(np.identity(cls.dim))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def identity( ... ):
    return  ... (np)

idx = 10:------------------- similar code ------------------ index = 25, score = 6.0 
def update_weights(robustifier, x_true, x_pred, weights):
    E = calc_errors(x_true, x_pred, weights)
    I = np.identity(2)
    return np.array([(I * w) for w in robustifier.weights(E)])

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
     ...  = np.identity

idx = 11:------------------- similar code ------------------ index = 11, score = 5.0 
def normalize(self):
    'Normalize the rotation matrix to ensure it is valid and\n        negate the effect of rounding errors.\n        '
    (U, _, V) = np.linalg.svd(self.mat, full_matrices=False)
    S = np.identity(self.dim)
    S[((self.dim - 1), (self.dim - 1))] = (np.linalg.det(U) * np.linalg.det(V))
    self.mat = U.dot(S).dot(V)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
     ...  = np.identity

idx = 12:------------------- similar code ------------------ index = 3, score = 5.0 
def solve_pnp(points, keypoints):
    assert (points.shape[0] == keypoints.shape[0])
    if (keypoints.shape[0] < min_correspondences):
        raise NotEnoughInliersException('No sufficient correspondences')
    t = calc_reprojection_threshold(keypoints, k=3.0)
    (retval, omega, t, inliers) = cv2.solvePnPRansac(points.astype(np.float64), keypoints.astype(np.float64), np.identity(3), np.zeros(4), reprojectionError=t, flags=cv2.SOLVEPNP_EPNP)
    if (not retval):
        raise RuntimeError('Pose estimation failed')
    if (len(inliers.flatten()) == 0):
        raise NotEnoughInliersException('No inliers found')
    return Pose(Rotation.from_rotvec(omega.flatten()), t.flatten())

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 =  ... . ... (,, np.identity,,,)

idx = 13:------------------- similar code ------------------ index = 5, score = 5.0 
@classmethod
def inv_left_jacobian(cls, phi):
    ':math:`SO(2)` inverse left Jacobian.\n\n        .. math::\n            \\mathbf{J}^{-1}(\\phi) = \n            \\begin{cases}\n                \\mathbf{1} - \\frac{1}{2} \\phi^\\wedge, & \\text{if } \\phi \\text{ is small} \\\\\n                \\frac{\\phi}{2} \\cot \\frac{\\phi}{2} \\mathbf{1} -\n                \\frac{\\phi}{2} 1^\\wedge, & \\text{otherwise}\n            \\end{cases}\n        '
    if np.isclose(phi, 0.0):
        return (np.identity(cls.dim) - (0.5 * cls.wedge(phi)))
    half_angle = (0.5 * phi)
    cot_half_angle = (1.0 / np.tan(half_angle))
    return (((half_angle * cot_half_angle) * np.identity(cls.dim)) - (half_angle * cls.wedge(1.0)))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    if:
        return (np.identity -)

idx = 14:------------------- similar code ------------------ index = 6, score = 5.0 
def log(self):
    'Logarithmic map for :math:`SO(3)`, which computes a tangent vector from a transformation:\n\n        .. math::\n            \\phi &= \\frac{1}{2} \\left( \\mathrm{Tr}(\\mathbf{C}) - 1 \\right) \\\\\n            \\boldsymbol{\\phi}(\\mathbf{C}) &= \n            \\ln(\\mathbf{C})^\\vee =\n            \\begin{cases}\n                \\mathbf{1} - \\boldsymbol{\\phi}^\\wedge, & \\text{if } \\phi \\text{ is small} \\\\\n                \\left( \\frac{1}{2} \\frac{\\phi}{\\sin \\phi} \\left( \\mathbf{C} - \\mathbf{C}^T \\right) \\right)^\\vee, & \\text{otherwise}\n            \\end{cases}\n\n        This is the inverse operation to :meth:`~liegroups.SO3.log`.\n        '
    cos_angle = ((0.5 * np.trace(self.mat)) - 0.5)
    cos_angle = np.clip(cos_angle, (- 1.0), 1.0)
    angle = np.arccos(cos_angle)
    if np.isclose(angle, 0.0):
        return self.vee((self.mat - np.identity(3)))
    return self.vee((((0.5 * angle) / np.sin(angle)) * (self.mat - self.mat.T)))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
    if:
        return  ... . ... (( - np.identity))

idx = 15:------------------- similar code ------------------ index = 7, score = 5.0 
def setUp(self):
    self.poscar = Poscar()
    self.poscar.title = 'Title'
    self.poscar.scaling = 1.0
    self.poscar.cell = Mock(spec=Cell)
    self.poscar.cell.matrix = np.identity(3)
    self.poscar.atoms = ['A']
    self.poscar.atom_numbers = [1]
    self.poscar.coordinate_type = 'Direct'
    self.poscar.coordinates = np.array([[0.0, 0.0, 0.0]])
    self.poscar.selective_dynamics = False

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
 = np.identity

idx = 16:------------------- similar code ------------------ index = 2, score = 5.0 
def is_rotation_matrix(R):
    assert (R.shape[0] == R.shape[1])
    I = np.identity(3)
    return (np.isclose(np.dot(R, R.T), I).all() and np.isclose(np.linalg.det(R), 1.0))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
     ...  = np.identity

idx = 17:------------------- similar code ------------------ index = 8, score = 5.0 
def select_valid_pose(R1A, R1B, t1a, t1b, keypoints0, keypoints1):
    (R0, t0) = (np.identity(3), np.zeros(3))
    n_max_valid_depth = (- 1)
    (argmax_R, argmax_t, argmax_depth_mask) = (None, None, None)
    indices = triangulation_indices(min(100, len(keypoints0)))
    keypoints = np.stack((keypoints0[indices], keypoints1[indices]))
    for (i, (R_, t_)) in enumerate(itertools.product((R1A, R1B), (t1a, t1b))):
        (_, depths) = linear_triangulation(np.array([R0, R_]), np.array([t0, t_]), keypoints)
        depth_mask = compute_depth_mask(depths)
        n_valid_depth = np.sum(depth_mask)
        if (n_valid_depth > n_max_valid_depth):
            n_max_valid_depth = n_valid_depth
            (argmax_R, argmax_t, argmax_depth_mask) = (R_, t_, depth_mask)
    if (not depth_condition(argmax_depth_mask)):
        warn_points_behind_cameras()
    return (argmax_R, argmax_t)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = (np.identity,)

idx = 18:------------------- similar code ------------------ index = 10, score = 5.0 
def test(R_true, t_true):
    S_true = tangent_so3(t_true)
    E_true = np.dot(R_true, S_true)
    (R1, R2, t1, t2) = decompose_essential(E_true)
    assert_array_almost_equal(t1, (- t2))
    assert_array_almost_equal(np.cross(np.dot(R1.T, t1), t_true), np.zeros(3))
    assert_array_almost_equal(np.cross(np.dot(R2.T, t1), t_true), np.zeros(3))
    assert_array_almost_equal(np.dot(R1.T, R1), np.identity(3))
    assert_array_almost_equal(np.dot(R2.T, R2), np.identity(3))
    assert_almost_equal(np.linalg.det(R1), 1.0)
    assert_almost_equal(np.linalg.det(R2), 1.0)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
     ... (, np.identity)

idx = 19:------------------- similar code ------------------ index = 31, score = 5.0 
@classmethod
def is_valid_matrix(cls, mat):
    'Check if a matrix is a valid rotation matrix.'
    return ((mat.shape == (cls.dim, cls.dim)) and np.isclose(np.linalg.det(mat), 1.0) and np.allclose(mat.T.dot(mat), np.identity(cls.dim)))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    return ( and  ... . ... (, np.identity))

idx = 20:------------------- similar code ------------------ index = 12, score = 5.0 
@classmethod
def exp(cls, phi):
    'Exponential map for :math:`SO(3)`, which computes a transformation from a tangent vector:\n\n        .. math::\n            \\mathbf{C}(\\boldsymbol{\\phi}) =\n            \\exp(\\boldsymbol{\\phi}^\\wedge) =\n            \\begin{cases}\n                \\mathbf{1} + \\boldsymbol{\\phi}^\\wedge, & \\text{if } \\phi \\text{ is small} \\\\\n                \\cos \\phi \\mathbf{1} +\n                (1 - \\cos \\phi) \\mathbf{a}\\mathbf{a}^T +\n                \\sin \\phi \\mathbf{a}^\\wedge, & \\text{otherwise}\n            \\end{cases}\n\n        This is the inverse operation to :meth:`~liegroups.SO3.log`.\n        '
    if (len(phi) != cls.dof):
        raise ValueError('phi must have length 3')
    angle = np.linalg.norm(phi)
    if np.isclose(angle, 0.0):
        return cls((np.identity(cls.dim) + cls.wedge(phi)))
    axis = (phi / angle)
    s = np.sin(angle)
    c = np.cos(angle)
    return cls((((c * np.identity(cls.dim)) + ((1 - c) * np.outer(axis, axis))) + (s * cls.wedge(axis))))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    if:
        return  ... ((np.identity +))

idx = 21:------------------- similar code ------------------ index = 13, score = 5.0 
@classmethod
def inv_left_jacobian(cls, phi):
    ':math:`SO(3)` inverse left Jacobian.\n\n        .. math::\n            \\mathbf{J}^{-1}(\\boldsymbol{\\phi}) =\n            \\begin{cases}\n                \\mathbf{1} - \\frac{1}{2} \\boldsymbol{\\phi}^\\wedge, & \\text{if } \\phi \\text{ is small} \\\\\n                \\frac{\\phi}{2} \\cot \\frac{\\phi}{2} \\mathbf{1} +\n                \\left( 1 - \\frac{\\phi}{2} \\cot \\frac{\\phi}{2} \\right) \\mathbf{a}\\mathbf{a}^T -\n                \\frac{\\phi}{2} \\mathbf{a}^\\wedge, & \\text{otherwise}\n            \\end{cases}\n        '
    if (len(phi) != cls.dof):
        raise ValueError('phi must have length 3')
    angle = np.linalg.norm(phi)
    if np.isclose(angle, 0.0):
        return (np.identity(cls.dof) - (0.5 * cls.wedge(phi)))
    axis = (phi / angle)
    half_angle = (0.5 * angle)
    cot_half_angle = (1.0 / np.tan(half_angle))
    return ((((half_angle * cot_half_angle) * np.identity(cls.dof)) + ((1 - (half_angle * cot_half_angle)) * np.outer(axis, axis))) - (half_angle * cls.wedge(axis)))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    if:
        return (np.identity -)

idx = 22:------------------- similar code ------------------ index = 14, score = 5.0 
def concatenate4x4(*matrix_Nx4x4):
    matrix = np.identity(4)
    for m in matrix_Nx4x4:
        matrix = np.matmul(matrix, m)
    return matrix

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
     ...  = np.identity

idx = 23:------------------- similar code ------------------ index = 30, score = 5.0 
def test_inv2x2():
    X = np.array([[100, 2], [40, (- 30)]], dtype=np.float64)
    assert_array_almost_equal(np.dot(inv2x2(X), X), np.identity(2))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
     ... (, np.identity)

idx = 24:------------------- similar code ------------------ index = 17, score = 5.0 
def __init__(self):
    self.title = 'Title'
    self.scaling = 1.0
    self.cell = cell.Cell(np.identity(3))
    self.atoms = ['A']
    self.atom_numbers = [1]
    self.coordinate_type = 'Direct'
    self.coordinates = np.array([[0.0, 0.0, 0.0]])
    self.selective_dynamics = False

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
 =  ... . ... (np.identity)

idx = 25:------------------- similar code ------------------ index = 18, score = 5.0 
@classmethod
def left_jacobian(cls, phi):
    ':math:`SO(3)` left Jacobian.\n\n        .. math::\n            \\mathbf{J}(\\boldsymbol{\\phi}) =\n            \\begin{cases}\n                \\mathbf{1} + \\frac{1}{2} \\boldsymbol{\\phi}^\\wedge, & \\text{if } \\phi \\text{ is small} \\\\\n                \\frac{\\sin \\phi}{\\phi} \\mathbf{1} +\n                \\left(1 - \\frac{\\sin \\phi}{\\phi} \\right) \\mathbf{a}\\mathbf{a}^T +\n                \\frac{1 - \\cos \\phi}{\\phi} \\mathbf{a}^\\wedge, & \\text{otherwise}\n            \\end{cases}\n        '
    if (len(phi) != cls.dof):
        raise ValueError('phi must have length 3')
    angle = np.linalg.norm(phi)
    if np.isclose(angle, 0.0):
        return (np.identity(cls.dof) + (0.5 * cls.wedge(phi)))
    axis = (phi / angle)
    s = np.sin(angle)
    c = np.cos(angle)
    return ((((s / angle) * np.identity(cls.dof)) + ((1 - (s / angle)) * np.outer(axis, axis))) + (((1 - c) / angle) * cls.wedge(axis)))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    if:
        return (np.identity +)

idx = 26:------------------- similar code ------------------ index = 19, score = 5.0 
def update(self, currentState, measurement, currentCovariance, error, driftError, measurementError, angularVelocity, dt):
    '\n\t\tCore function of Kalman relating to its implmentation\n\n\t\tParameters\n\t\t----------\n\t\tcurrentState: float array \n\t\t\t\t\tIt is current state of the sensor which implies current \n\t\t\t\t\torientation in a specific axis and its corresponding \n\t\t\t\t\tbias. ex - [roll, roll_bias]\n\t\tmeasurement: float \n\t\t\testimate of the orinetation by the sensor. ex - measuredRoll\n\t\tcurrentCovariance: 2*2 array \n\t\t\t\t\t\tThis represents matrix relating orientation and bias\n\t\t\t\t\t\tex - rollCovariance\n\t\terror: float\n\t\t\tThis represents error in estimating the orientation\n\t\tdriftError: float\n\t\t\t\tThis represents error in estimating the  bias in orientation\n\t\tmeasurementError: float\n\t\t\t\t\t\tThis represents error in sensor values\n\t\tangularVelocity: float\n\t\t\t\t\t\tThe angular velocity about the direction\n\t\t\t\t\t\tof orientation\n\t\tdt: float\n\t\t\ttime interval for kalman filter to be applied\n\n\t\tReturns\n\t\t-------\n\t\torientation: float\n\t\t\t\t\tIt is the corrected angle from previous\n\t\t\t\t\testimate and current measurment\n\t\tcorrectedState:\n\t\t\t\t\tIt is the corrected state from previous\n\t\t\t\t\testimate and current measurment\n\t\tupdatedCovariance: \n\t\t\t\t\tNew updated covariance after taking \n\t\t\t\t\tnew measurement into consideration\n\n\t\t'
    motionModel = np.array([[1, ((- 1) * dt)], [0, 1]])
    prediction = (np.matmul(motionModel, currentState) + (dt * np.vstack((angularVelocity, 0.0))))
    errorMatrix = (np.array([error, driftError]) * np.identity(2))
    predictedCovariance = (np.matmul(np.matmul(motionModel, currentCovariance), motionModel.T) + errorMatrix)
    difference = (measurement - np.matmul(np.array([1.0, 1.0]), prediction))
    measurementCovariance = (np.matmul(np.matmul(np.array([1.0, 0.0]), predictedCovariance), np.vstack((1.0, 0.0))) + measurementError)
    kalmanGain = (np.matmul(predictedCovariance, np.vstack((1.0, 0.0))) / measurementCovariance)
    correctedState = (prediction + (kalmanGain * (measurement - np.matmul(np.array([1.0, 0.0]), prediction))))
    updatedCovariance = np.matmul((np.identity(2) - np.matmul(kalmanGain, np.array([1.0, 0.0]).reshape((1, 2)))), predictedCovariance)
    return (correctedState[(0, 0)], correctedState, updatedCovariance)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
     ...  = ( * np.identity)

idx = 27:------------------- similar code ------------------ index = 20, score = 5.0 
def get_multivariate_simple():
    dim = 3
    scale = np.identity(3, dtype=np.float32)
    num_datapoints = 4
    data = np.array([[0.0, 1.0, 0.0], [(- 0.2), 1.1, 0.1], [0.5, 1.2, 0.2], [1.0, (- 0.2), (- 1.2)]], dtype=np.float32)

    def multivariate_normal_model(num_datapoints):
        A = ed.Wishart(df=dim, scale=scale, name='A')
        x = ed.MultivariateNormalFullCovariance(loc=tf.zeros(dim), covariance_matrix=A, name='x')
        loc = (tf.ones([num_datapoints, 1]) * x)
        y = ed.Normal(loc=loc, scale=1.0, name='y')
        return y
    model_args = [num_datapoints]
    observed = {'y': data}
    varnames = ['V', 'x']
    param_names = [p for v in varnames for p in ((v + '_a'), (v + '_b'), (v + '_c'))]
    noncentered_parameterization = {p: 0.0 for p in param_names}
    make_to_centered = build_make_to_centered(multivariate_normal_model, model_args=model_args, observed_data=observed)
    make_to_partially_noncentered = build_make_to_partially_noncentered(multivariate_normal_model, model_args=model_args, observed_data=observed)
    to_centered = make_to_centered(**noncentered_parameterization)
    to_noncentered = make_to_noncentered(multivariate_normal_model, model_args=model_args, observed_data=observed)
    return ModelConfig(multivariate_normal_model, model_args, observed, to_centered, to_noncentered, make_to_centered, make_to_partially_noncentered, None)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
     ...  = np.identity

idx = 28:------------------- similar code ------------------ index = 27, score = 5.0 
@classmethod
def left_jacobian(cls, phi):
    ':math:`SO(2)` left Jacobian.\n\n        .. math::\n            \\mathbf{J}(\\phi) = \n            \\begin{cases}\n                \\mathbf{1} + \\frac{1}{2} \\phi^\\wedge, & \\text{if } \\phi \\text{ is small} \\\\\n                \\frac{\\sin \\phi}{\\phi} \\mathbf{1} - \n                \\frac{1 - \\cos \\phi}{\\phi} 1^\\wedge, & \\text{otherwise}\n            \\end{cases}\n        '
    if np.isclose(phi, 0.0):
        return (np.identity(cls.dim) + (0.5 * cls.wedge(phi)))
    s = np.sin(phi)
    c = np.cos(phi)
    return (((s / phi) * np.identity(cls.dim)) + (((1 - c) / phi) * cls.wedge(1.0)))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    if:
        return (np.identity +)

idx = 29:------------------- similar code ------------------ index = 28, score = 5.0 
def test_R():
    pose = Pose(Rotation.from_rotvec(np.zeros(3)), np.zeros(3))
    assert_array_almost_equal(pose.R, np.identity(3))
    (rotvec, t) = (np.array([np.pi, 0, 0]), np.zeros(3))
    pose = Pose(Rotation.from_rotvec(rotvec), t)
    assert_array_almost_equal(pose.R, np.diag([1, (- 1), (- 1)]))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
     ... (, np.identity)

idx = 30:------------------- similar code ------------------ index = 29, score = 5.0 
def test_decompose_essential():

    def test(R_true, t_true):
        S_true = tangent_so3(t_true)
        E_true = np.dot(R_true, S_true)
        (R1, R2, t1, t2) = decompose_essential(E_true)
        assert_array_almost_equal(t1, (- t2))
        assert_array_almost_equal(np.cross(np.dot(R1.T, t1), t_true), np.zeros(3))
        assert_array_almost_equal(np.cross(np.dot(R2.T, t1), t_true), np.zeros(3))
        assert_array_almost_equal(np.dot(R1.T, R1), np.identity(3))
        assert_array_almost_equal(np.dot(R2.T, R2), np.identity(3))
        assert_almost_equal(np.linalg.det(R1), 1.0)
        assert_almost_equal(np.linalg.det(R2), 1.0)
    N = 10
    angles = np.random.uniform((- np.pi), np.pi, (N, 3))
    rotations = Rotation.from_euler('xyz', angles).as_matrix()
    translations = np.random.uniform((- 10), 10, (N, 3))
    for (R, t) in itertools.product(rotations, translations):
        test(R, t)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():

    def  ... ():
         ... (, np.identity)

idx = 31:------------------- similar code ------------------ index = 15, score = 4.0 
def load_batch(fpath):
    f = open(fpath, 'rb').read()
    size = (((32 * 32) * 3) + 1)
    labels = []
    images = []
    for i in range(10000):
        arr = np.fromstring(f[(i * size):((i + 1) * size)], dtype=np.uint8)
        lab = np.identity(10)[arr[0]]
        img = arr[1:].reshape((3, 32, 32)).transpose((1, 2, 0))
        labels.append(lab)
        images.append(((img / 255) - 0.5))
    return (np.array(images), np.array(labels))

------------------- similar code (pruned) ------------------ score = 0.35714285714285715 
def  ... ( ... ):
    for  ...  in:
         ...  = np
         ...  =  ... .identity

