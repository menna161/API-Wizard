import getopt
import os
import re
import sys
import types
import random
import shutil
import struct
import string
import types
import urllib
import inspect
import datetime
import binascii
import itertools
import traceback
import pickle
import json
from operator import itemgetter
from collections import defaultdict, namedtuple
import cProfile
import pstats
import copy
import immlib as dbglib
from immlib import LogBpHook
from immutils import *
import time
import pykd
import windbglib as dbglib
from windbglib import LogBpHook
import copy, random, time
import sys
import sys
import traceback
import traceback


def reset(self, clear=True, showheader=True):
    "\n\t\tOptionally clears a log file, write a header to the log file and return filename\n\n\t\tOptional :\n\t\tclear = Boolean. When set to false, the logfile won't be cleared. This method can be\n\t\tused to retrieve the full path to the logfile name of the current MnLog class object\n\t\tLogfiles are written to the debugger program folder, unless a config value 'workingfolder' is set.\n\n\t\tReturn:\n\t\tfull path to the logfile name.\n\t\t"
    global noheader
    if clear:
        if (not silent):
            dbg.log((("[+] Preparing output file '" + self.filename) + "'"))
    if (not showheader):
        noheader = True
    debuggedname = dbg.getDebuggedName()
    thispid = dbg.getDebuggedPid()
    if (thispid == 0):
        debuggedname = '_no_name_'
    thisconfig = MnConfig()
    workingfolder = thisconfig.get('workingfolder').rstrip('\\').strip()
    parts = debuggedname.split('.')
    extlen = (len(parts[(len(parts) - 1)]) + 1)
    debuggedname = debuggedname[0:(len(debuggedname) - extlen)]
    debuggedname = debuggedname.replace(' ', '_')
    workingfolder = workingfolder.replace('%p', debuggedname)
    workingfolder = workingfolder.replace('%i', str(thispid))
    logfile = getAbsolutePath(self.filename)
    if clear:
        if (not silent):
            dbg.log(('    - (Re)setting logfile %s' % logfile))
        try:
            if os.path.exists(logfile):
                try:
                    os.delete((logfile + '.old'))
                except:
                    pass
                try:
                    os.rename(logfile, (logfile + '.old'))
                except:
                    try:
                        os.rename(logfile, (logfile + '.old2'))
                    except:
                        pass
        except:
            pass
        if (not noheader):
            try:
                with open(logfile, 'w') as fh:
                    fh.write((('=' * 80) + '\n'))
                    (thisversion, thisrevision) = getVersionInfo(inspect.stack()[0][1])
                    thisversion = thisversion.replace("'", '')
                    fh.write((((((('  Output generated by mona.py v' + thisversion) + ', rev ') + thisrevision) + ' - ') + __DEBUGGERAPP__) + '\n'))
                    fh.write('  Corelan Consulting bv - https://www.corelan.be\n')
                    fh.write((('=' * 80) + '\n'))
                    osver = dbg.getOsVersion()
                    osrel = dbg.getOsRelease()
                    fh.write((((('  OS : ' + osver) + ', release ') + osrel) + '\n'))
                    fh.write((((('  Process being debugged : ' + debuggedname) + ' (pid ') + str(thispid)) + ')\n'))
                    currmonaargs = ' '.join((x for x in currentArgs))
                    fh.write(('  Current mona arguments: %s\n' % currmonaargs))
                    fh.write((('=' * 80) + '\n'))
                    fh.write((('  ' + datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')) + '\n'))
                    fh.write((('=' * 80) + '\n'))
            except:
                pass
        else:
            try:
                with open(logfile, 'w') as fh:
                    fh.write('')
            except:
                pass
        try:
            if (not ignoremodules):
                showModuleTable(logfile)
        except:
            pass
    return logfile
