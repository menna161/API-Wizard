------------------------- example 1 ------------------------ 
def plot_routes(sol_file_name):
    plot_file_name = (sol_file_name[0:sol_file_name.rfind('.json')] + '.svg')
    print(('Parsing ' + sol_file_name))
// your code ...
    (fig, ax1) = plt.subplots(1, 1)
    fig.set_figwidth(15)
    plt.subplots_adjust(left=0.03, right=1, top=1, bottom=0.05, wspace=0.03)
    if ('routes' not in solution):
// your code ...
    xmin = solution['routes'][0]['steps'][0]['location'][0]
    xmax = xmin
// your code ...
    for route in solution['routes']:
        lons = [step['location'][0] for step in route['steps'] if (step['type'] != 'break')]
// your code ...
        ax1.plot(lons, lats, color=color_list[(route['vehicle'] % len(color_list))])
        xmin = min(xmin, min(lons))
// your code ...
    if (('unassigned' in solution) and (len(solution['unassigned']) > 0)):
// your code ...
    title = plot_file_name[:plot_file_name.rfind('.')]
    title += (' ; cost: ' + str(solution['summary']['cost']))
    title += (' ; computing time: ' + str(computing_time))
// your code ...
    ax1.set_title(title)
    ax1.set_xlim((xmin - margin_delta), (xmax + margin_delta))
// your code ...

------------------------- example 2 ------------------------ 
def plot_ablation(extension):
    yolo_path_n_lookback_0 = os.path.join(data_dir, 'ablation/run_search_yolo-air-ablation-n-lookback=0_env=task=scatter_alg=yolo-air-transfer_duration=long_seed=0_2018_09_03_08_52_37/')
// your code ...
    (fig, axes) = plt.subplots(1, 3, figsize=(8, 2.2))
    ax = axes[0]
    y_func = (lambda y: (100 * y))
// your code ...
    nb0_data = get_transfer_data(yolo_path_n_lookback_0, 'n_train', measure, 'ci95', y_func=y_func)
    for ((x, y, *yerr), key) in nb0_data:
        if (not key_filter(key)):
// your code ...
        label = 'No Lateral Conns, {}--{} digits'.format(key.min_chars, key.max_chars)
        ax.errorbar(x, y, yerr=yerr, label=label)
    nb1_data = get_transfer_data(yolo_path_n_lookback_1, 'n_train', measure, 'ci95', y_func=y_func)
    for ((x, y, *yerr), key) in nb1_data:
        if (not key_filter(key)):
// your code ...
        label = 'With Lateral Conns, {}--{} digits'.format(key.min_chars, key.max_chars)
        ax.errorbar(x, y, yerr=yerr, label=label)
    fontsize = None
// your code ...
    ax.set_ylabel('Average Precision', fontsize=fontsize)
    ax.tick_params(axis='both', labelsize=labelsize)
    ax.set_ylim((0.0, 105.0))
    ax.set_xlabel('\\# Digits in Test Image', fontsize=fontsize)
    ax.set_xticks([0, 5, 10, 15, 20])
    ax.legend(loc='lower left', fontsize=8)
    ax = axes[1]
    measure = '_test_count_1norm'
// your code ...
    for ((x, y, *yerr), key) in nb0_data:
        if (not key_filter(key)):
// your code ...
        ax.errorbar(x, y, yerr=yerr)
    nb1_data = get_transfer_data(yolo_path_n_lookback_1, 'n_train', measure, 'ci95')
    for ((x, y, *yerr), key) in nb1_data:
        if (not key_filter(key)):
// your code ...
        ax.errorbar(x, y, yerr=yerr)
    ax.set_ylabel('Count Absolute Error', fontsize=fontsize)
    ax.set_xlabel('\\# Digits in Test Image', fontsize=fontsize)
    ax.tick_params(axis='both', labelsize=labelsize)
    ax.set_ylim((0.0, 4.0))
    ax.set_xticks([0, 5, 10, 15, 20])
    ax = axes[2]
// your code ...
    plt.subplots_adjust(left=0.07, bottom=0.2, right=0.98, top=0.94, wspace=0.27)
    plot_path = os.path.join(plot_dir, ('ablation/main.' + extension))
// your code ...
    fig.savefig(plot_path)
    plt.show()

------------------------- example 3 ------------------------ 
def plot_masks(nrows, ncols, generation_order, masks, k=3, out_path=None):
    import time
    (fig, axes) = plt.subplots(nrows, ncols)
    plt.suptitle(f'Kernel masks')
    for (row_major_index, ((r, c), mask)) in enumerate(zip(generation_order, masks)):
        axes[((row_major_index // your code ... ncols), (row_major_index % ncols))].imshow(mask, vmin=0, vmax=1)
    plt.setp(axes, xticks=[], yticks=[])
    if out_path:
// your code ...
    else:
        plt.show()

------------------------- example 4 ------------------------ 
def draw_r0_daily_evolution(stats_arg, show_plot, x_tick=10):
    (fig, ax) = plt.subplots(figsize=(15, 10))
    set_ax_r0(ax, stats_arg['R0d'], 'R0 Daily', x_tick=10)
    if show_plot:
        plt.show()
    else:
        plt.savefig(('images/output/%d-R0-daily-%d-%d.png' % (ts, stats_arg['hea'].shape[0], np.max(stats_arg['hea']))))

------------------------- example 5 ------------------------ 
def table_box_plot(setting, landmarks, compare_list=None, fig_measure_list=None, plot_per_pair=False, fig_ext='.png', plot_folder=None, paper_table=None, naming_strategy=None, jacobian=False, multi_jac_exp_list=None):
    "\n    merge the landmarks from different cases\n    :param setting:\n    :param landmarks:\n    :param compare_list:\n    :param\n    :param plot_folder: one of the experiment to save all plots in that directory. The plot folder should consider also the stages\n    for example: my_experiment_S4_S2_S1. if None, the last experiment will be chosen as the plot folder\n    :param naming_strategy: None\n                            'Fancy'\n                            'Clean'\n    :param paper_table: 'SPREAD', 'DIR-Lab'\n    :return:\n    "
// your code ...
    if (plot_folder is None):
        plot_key = list(landmarks.items())[(- 1)][0]
    else:
// your code ...
    header = {'exp': 0, 'TRE_Mean': 1, 'TRE_STD': 2, 'TRE_Median': 3, 'MAE0_Mean': 4, 'MAE0_STD': 5, 'MAE1_Mean': 6, 'MAE1_STD': 7, 'MAE2_Mean': 8, 'MAE2_STD': 9, 'Jac_FoldingPercentage': 10, 'Jac_STD': 11, 'Error0_Mean': 12, 'Error0_STD': 13, 'Error1_Mean': 14, 'Error1_STD': 15, 'Error2_Mean': 16, 'Error2_STD': 17}
    for key in header.keys():
// your code ...
    for (exp_i, exp) in enumerate(landmarks.keys()):
        landmarks_merged[exp] = {'TRE': np.empty([0]), 'Error': np.empty([0, 3]), 'CleanName': su.clean_exp_name(exp), 'FancyName': su.fancy_exp_name(exp), 'Jac_NumberOfNegativeJacVoxels': 0, 'Jac_MaskSize': 0, 'Jac_Var': 0, 'Jac_STD_List': [], 'Jac_FoldingPercentage_List': []}
        num_pair = len(landmarks[exp])
// your code ...
    workbook.close()
// your code ...
    for measure in fig_measure_list:
        if plot_per_pair:
            for pair_i in range(len(landmarks[next(iter(landmarks))])):
                (fig, ax) = plt.subplots(figsize=(15, 8))
                bplot1 = plt.boxplot([landmarks[exp][pair_i]['landmark_info'][measure] for exp in landmarks.keys()], patch_artist=True, notch=True)
// your code ...
        (fig, ax) = plt.subplots(figsize=(15, 8))
        bplot1 = plt.boxplot([landmarks_merged[exp][measure] for exp in landmarks_merged.keys()], patch_artist=True, notch=True)
// your code ...
        plt.close()

examples  ||  representativeness  ||  number of lines  || number of comments   ||  relevancy  
example1  ||          4           ||        19         ||         8        ||        0.3157894736842105         
example2  ||          3           ||        41         ||         10        ||        0.14634146341463414         
example3  ||          9           ||        9         ||         2        ||        0.2222222222222222         
example4  ||          6           ||        7         ||         0        ||        0.14285714285714285         
example5  ||          6           ||        19         ||         7        ||        0.10526315789473684         

avg       ||          5.490196078431373           ||        19.0         ||         5.4        ||         18.64946920145893        

idx = 0:------------------- similar code ------------------ index = 24, score = 6.0 
def boxplot_tre(landmarks, exp_list, normalize=True, min1=20, max1=90, min2=20, max2=30, dash_line_exp=None, threshold=None, ylim=None):
    tre = dict()
    error = dict()
    fancy_name = dict()
    for exp in exp_list:
        tre[exp] = np.copy(landmarks[exp]['TRE'])
        error[exp] = np.copy(landmarks[exp]['Error'])
        fancy_name[exp] = landmarks[exp]['FancyName']
    if (threshold is None):
        ytick_value = [0, 5, 10, 15, min2, max2]
        ytick_label = ['0', '5', '10', '15', str(min1), str(max1)]
        title = 'TRE [mm] of all landmarks'
    else:
        affine_error = error['Affine']
        selected_landmarks = np.where(np.all((np.abs(affine_error) <= threshold), axis=1))
        for exp in exp_list:
            tre[exp] = tre[exp][selected_landmarks]
        ytick_value = [0, 5, 10, 15]
        ytick_label = [str(i) for i in ytick_value]
        while (ytick_value[(- 1)] < (threshold + 5)):
            ytick_value.append((ytick_value[(- 1)] + 5))
            ytick_label.append(str((ytick_value[(- 2)] + 5)))
        title = 'TRE [mm] of the capture range of {}'.format(threshold)
    if normalize:
        for exp in exp_list:
            ix = np.where((tre[exp] > min1))
            tre[exp][ix] = ((((tre[exp][ix] - min1) * (max2 - min1)) / (max1 - min2)) + min2)
    plt.rc('font', family='serif')
    (fig, ax) = plt.subplots(figsize=(15, 8))
    bplot1 = plt.boxplot([tre[exp] for exp in exp_list], patch_artist=True, notch=True)
    color_dict = color_constants.color_dict()
    color_keys = ['blue', 'springgreen', 'sapgreen', 'cyan2', 'peacock']
    color_list = [color_dict[color_key] for color_key in color_keys]
    for (i_patch, patch) in enumerate(bplot1['boxes']):
        if (i_patch == 0):
            color_i = 0
        elif (0 < i_patch < 3):
            color_i = 1
        elif (i_patch == 3):
            color_i = 2
        else:
            color_i = 3
        patch.set_facecolor(color_list[color_i])
    plt.xticks(np.arange(1, (len(exp_list) + 1)), [fancy_name[exp] for exp in exp_list], fontsize=16, rotation=90)
    plt.yticks(ytick_value, ytick_label, fontsize=24)
    if (dash_line_exp is not None):
        exp_i = np.where((np.array(exp_list) == dash_line_exp))
        plt.axhline(y=bplot1['boxes'][exp_i[0][0]]._path.vertices[(2, 1)], color='r', linestyle=':')
    if (ylim is not None):
        plt.ylim([0, ylim])
    plt.subplots_adjust(hspace=0, bottom=0.5)
    plt.title(title)
    plt.draw()

------------------- similar code (pruned) ------------------ score = 0.5833333333333334 
def  ... ():
    plt
 =  ... .subplots

idx = 1:------------------- similar code ------------------ index = 15, score = 6.0 
def table_tre(landmarks, exp_list, threshold=None):
    tre = dict()
    error = dict()
    fancy_name = dict()
    for exp in exp_list:
        tre[exp] = np.copy(landmarks[exp]['TRE'])
        error[exp] = np.copy(landmarks[exp]['Error'])
        fancy_name[exp] = landmarks[exp]['FancyName']
    tab = dict()
    latex_str = {}
    header_tab = ['exp', 'measure', 'measure_x', 'measure_y', 'measure_z']
    value_tab = np.empty([len(exp_list), 5], dtype=object)
    if (threshold is None):
        selected_landmarks = np.arange(len(landmarks[next(iter(landmarks))]['Error']))
    else:
        affine_error = error['Affine']
        selected_landmarks = np.where(np.all((np.abs(affine_error) <= threshold), axis=1))
        selected_landmarks = selected_landmarks[0]
    selected_landmarks = selected_landmarks.astype(np.int)
    for (i, exp) in enumerate(exp_list):
        tab[exp] = {}
        latex_str[exp] = (('&' + fancy_name[exp]) + ' &test ')
        tab[exp]['mean'] = np.mean(tre[exp][selected_landmarks])
        tab[exp]['std'] = np.std(tre[exp][selected_landmarks])
        value_tab[(i, 0)] = fancy_name[exp]
        value_tab[(i, 1)] = '${:.2f}\\pm{:.2f}$'.format(tab[exp]['mean'], tab[exp]['std'])
        latex_str[exp] += '&\\scriptsize${:.2f}\\pm{:.2f}$'.format(tab[exp]['mean'], tab[exp]['std'])
        for dim in range(3):
            tab[exp][('dim' + str(dim))] = {}
            tab[exp][('dim' + str(dim))]['mean'] = np.mean(np.abs([error[exp][k][dim] for k in selected_landmarks]))
            tab[exp][('dim' + str(dim))]['std'] = np.std(np.abs([error[exp][k][dim] for k in selected_landmarks]))
            value_tab[(i, (dim + 2))] = '${:.2f}\\pm{:.2f}$'.format(tab[exp][('dim' + str(dim))]['mean'], tab[exp][('dim' + str(dim))]['std'])
            latex_str[exp] += (' & ' + '\\scriptsize${:.2f}\\pm{:.2f}$'.format(tab[exp][('dim' + str(dim))]['mean'], tab[exp][('dim' + str(dim))]['std']))
        latex_str[exp] += '\\\\'
        print(latex_str[exp])
    plt.rc('font', family='serif')
    (fig, ax) = plt.subplots(figsize=(15, 8))
    fig.patch.set_visible(False)
    ax.table(cellText=value_tab, colLabels=header_tab, loc='center', colLoc='left', cellLoc='left', fontsize=50)
    ax.axis('off')
    ax.axis('tight')
    fig.tight_layout()
    if threshold:
        plt.title('TRE [mm] of the capture range of {}'.format(threshold))
    plt.draw()

------------------- similar code (pruned) ------------------ score = 0.5833333333333334 
def  ... ():
    plt
 =  ... .subplots

idx = 2:------------------- similar code ------------------ index = 41, score = 6.0 
def L_curve(A, y, visible=None):
    "\n    Minimize the Lagrangian L(x,lambda) = || A*x - y||**2 + lambda*||x||**2 based on the idea of Tikhonov Regularization.\n    This program is used to accurately estimate the parameters x and the Lagrange multiplier lambda. \n    The final Lagrange multiplier is determained by the L-curve method. The L-curve can be visualized by outputing an image.\n\n    Usage:\n    accu_lamb,accu_x = L_curve(A,y) \n\n    Inputs:\n    A -> [float 2d array] Design matrix\n    y -> [float array] Measurements\n\n    Parameters:\n    visible -> [optional, str, default = None] If None, the visualization of L-vurve will be closed. If 'visible', the L-curve will be visualized by outputing an image.\n    \n    Outputs:\n    accu_lamb -> [float] Lagrange multiplier\n    accu_x -> [float array] Estimated parameters\n    \n    For more information, please refer to \n    (1) [NumPy/SciPy Recipes for Data Science: Regularized Least Squares Optimization](https://www.researchgate.net/publication/274138835_NumPy_SciPy_Recipes_for_Data_Science_Regularized_Least_Squares_Optimization)\n    (2) [Choosing the Regularization Parameter](http://www2.compute.dtu.dk/~pcha/DIP/chap5.pdf)\n    "
    m = A.shape[1]
    (appr_lamb, appr_x, log10_residual_norm, log10_solution_norm, appr_curvature) = solve_lambda_x(A, y)
    lambs_exponent = np.linspace((np.log10(appr_lamb) - 2), (np.log10(appr_lamb) + 2), 2000)
    (accu_lamb, accu_x, log10_residual_norm, log10_solution_norm, accu_curvature) = solve_lambda_x(A, y, lambs_exponent)
    if (visible is not None):
        fig_dir = 'figures/'
        if (not os.path.exists(fig_dir)):
            os.makedirs(fig_dir)
        plt.clf()
        (fig, (ax1, ax2)) = plt.subplots(1, 2, dpi=200)
        fig.subplots_adjust(wspace=0.4)
        ax1.plot(log10_residual_norm, log10_solution_norm)
        ax1.set_xlabel('$\\log \\parallel A x_{\\lambda}-y \\parallel_2$')
        ax1.set_ylabel('$\\log \\parallel x_{\\lambda} \\parallel_2$')
        ax1.set_title('L-Curve')
        ax2.plot(lambs_exponent, accu_curvature)
        ax2.set_xlabel('$\\log \\parallel \\lambda \\parallel_2$')
        ax2.set_ylabel('Curvature')
        ax2.set_title('curvature of L-Curve')
        plt.savefig((fig_dir + 'L-Curve.png'))
    return (accu_lamb, accu_x)

------------------- similar code (pruned) ------------------ score = 0.5833333333333334 
def  ... ():
    if:
        plt
 =  ... .subplots

idx = 3:------------------- similar code ------------------ index = 66, score = 6.0 
@exp.automain
def compute_components(n_components, batch_size, learning_rate, method, reduction, alpha, step_size, n_jobs, n_epochs, verbose, source, _run):
    basedir = join(_run.observers[0].basedir, str(_run._id))
    artifact_dir = join(basedir, 'artifacts')
    if (not os.path.exists(artifact_dir)):
        os.makedirs(artifact_dir)
    if (source == 'hcp'):
        train_size = None
        smoothing_fwhm = 3
        test_size = 2
        data_dir = get_data_dirs()[0]
        mask = fetch_hcp_mask()
        masker = MultiRawMasker(mask_img=mask, smoothing_fwhm=smoothing_fwhm, detrend=True, standardize=True)
        mapping = json.load(open(join(data_dir, 'HCP_unmasked/mapping.json'), 'r'))
        data = sorted(list(mapping.values()))
        data = list(map((lambda x: join(data_dir, x)), data))
        data = pd.DataFrame(data, columns=['filename'])
    else:
        smoothing_fwhm = 6
        train_size = 4
        test_size = 4
        raw_res_dir = join(get_output_dir(), 'unmasked', source)
        try:
            (masker, data) = get_raw_rest_data(raw_res_dir)
        except ValueError:
            raw_res_dir = join(get_output_dir(), 'unmask', source)
            (masker, data) = get_raw_rest_data(raw_res_dir)
    (train_imgs, test_imgs) = train_test_split(data, test_size=test_size, random_state=0, train_size=train_size)
    train_imgs = train_imgs['filename'].values
    test_imgs = test_imgs['filename'].values
    cb = rfMRIDictionaryScorer(test_imgs, info=_run.info)
    dict_fact = fMRIDictFact(method=method, mask=masker, verbose=verbose, n_epochs=n_epochs, n_jobs=n_jobs, random_state=1, n_components=n_components, smoothing_fwhm=smoothing_fwhm, learning_rate=learning_rate, batch_size=batch_size, reduction=reduction, step_size=step_size, alpha=alpha, callback=cb)
    dict_fact.fit(train_imgs)
    dict_fact.components_img_.to_filename(join(artifact_dir, 'components.nii.gz'))
    fig = plt.figure()
    display_maps(fig, dict_fact.components_img_)
    plt.savefig(join(artifact_dir, 'components.png'))
    (fig, ax) = plt.subplots(1, 1)
    ax.plot(cb.cpu_time, cb.score, marker='o')
    _run.info['time'] = cb.cpu_time
    _run.info['score'] = cb.score
    _run.info['iter'] = cb.iter
    plt.savefig(join(artifact_dir, 'score.png'))

------------------- similar code (pruned) ------------------ score = 0.5833333333333334 
def  ... ():
    plt
 =  ... .subplots

idx = 4:------------------- similar code ------------------ index = 75, score = 6.0 
def plot_routes(sol_file_name):
    plot_file_name = (sol_file_name[0:sol_file_name.rfind('.json')] + '.svg')
    print(('Parsing ' + sol_file_name))
    with open(sol_file_name, 'r') as sol_file:
        solution = json.load(sol_file)
    (fig, ax1) = plt.subplots(1, 1)
    fig.set_figwidth(15)
    plt.subplots_adjust(left=0.03, right=1, top=1, bottom=0.05, wspace=0.03)
    if ('routes' not in solution):
        return
    xmin = solution['routes'][0]['steps'][0]['location'][0]
    xmax = xmin
    ymin = solution['routes'][0]['steps'][0]['location'][1]
    ymax = ymin
    for route in solution['routes']:
        lons = [step['location'][0] for step in route['steps'] if (step['type'] != 'break')]
        lats = [step['location'][1] for step in route['steps'] if (step['type'] != 'break')]
        ax1.plot(lons, lats, color=color_list[(route['vehicle'] % len(color_list))])
        xmin = min(xmin, min(lons))
        xmax = max(xmax, max(lons))
        ymin = min(ymin, min(lats))
        ymax = max(ymax, max(lats))
        step = route['steps'][(- 1)]
        if (step['type'] == 'end'):
            ax1.scatter([step['location'][0]], [step['location'][1]], color='red', linewidth=8)
        step = route['steps'][0]
        if (step['type'] == 'start'):
            ax1.scatter([step['location'][0]], [step['location'][1]], color='green', linewidth=1)
        for step in route['steps']:
            if (step['type'] == 'job'):
                marker_shape = 'o'
                marker_color = 'blue'
            elif (step['type'] == 'pickup'):
                marker_shape = '^'
                marker_color = 'red'
            elif (step['type'] == 'delivery'):
                marker_shape = 'v'
                marker_color = 'green'
            else:
                continue
            ax1.scatter([step['location'][0]], [step['location'][1]], facecolor='none', edgecolor=marker_color, marker=marker_shape, linewidth=0.7)
    if (('unassigned' in solution) and (len(solution['unassigned']) > 0)):
        unassigned_lons = [u['location'][0] for u in solution['unassigned']]
        unassigned_lats = [u['location'][1] for u in solution['unassigned']]
        ax1.scatter(unassigned_lons, unassigned_lats, marker='x', color='red', s=100)
        xmin = min(xmin, min(unassigned_lons))
        xmax = max(xmax, max(unassigned_lons))
        ymin = min(ymin, min(unassigned_lats))
        ymax = max(ymax, max(unassigned_lats))
    computing_time = solution['summary']['computing_times']['loading']
    computing_time += solution['summary']['computing_times']['solving']
    if ('routing' in solution['summary']['computing_times']):
        computing_time += solution['summary']['computing_times']['routing']
    size_factor = max(((xmax - xmin) / 100), ((ymax - ymin) / 100))
    margin_delta = (3 * size_factor)
    title = plot_file_name[:plot_file_name.rfind('.')]
    title += (' ; cost: ' + str(solution['summary']['cost']))
    title += (' ; computing time: ' + str(computing_time))
    title += 'ms'
    ax1.set_title(title)
    ax1.set_xlim((xmin - margin_delta), (xmax + margin_delta))
    ax1.set_ylim((ymin - margin_delta), (ymax + margin_delta))
    ax1.set_aspect('equal')
    print(('Plotting file ' + plot_file_name))
    plt.savefig(plot_file_name, bbox_inches='tight')
    plt.close()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
 = plt.subplots

idx = 5:------------------- similar code ------------------ index = 43, score = 6.0 
def plot_ablation(extension):
    yolo_path_n_lookback_0 = os.path.join(data_dir, 'ablation/run_search_yolo-air-ablation-n-lookback=0_env=task=scatter_alg=yolo-air-transfer_duration=long_seed=0_2018_09_03_08_52_37/')
    yolo_path_n_lookback_1 = os.path.join(data_dir, 'ablation/run_search_yolo-air-ablation-n-lookback=1_env=task=scatter_alg=yolo-air-transfer_duration=long_seed=0_2018_09_03_09_00_25/')
    (fig, axes) = plt.subplots(1, 3, figsize=(8, 2.2))
    ax = axes[0]
    y_func = (lambda y: (100 * y))
    measure = '_test_AP'
    key_filter = (lambda key: (key.min_chars not in [1, 6]))
    nb0_data = get_transfer_data(yolo_path_n_lookback_0, 'n_train', measure, 'ci95', y_func=y_func)
    for ((x, y, *yerr), key) in nb0_data:
        if (not key_filter(key)):
            continue
        label = 'No Lateral Conns, {}--{} digits'.format(key.min_chars, key.max_chars)
        ax.errorbar(x, y, yerr=yerr, label=label)
    nb1_data = get_transfer_data(yolo_path_n_lookback_1, 'n_train', measure, 'ci95', y_func=y_func)
    for ((x, y, *yerr), key) in nb1_data:
        if (not key_filter(key)):
            continue
        label = 'With Lateral Conns, {}--{} digits'.format(key.min_chars, key.max_chars)
        ax.errorbar(x, y, yerr=yerr, label=label)
    fontsize = None
    labelsize = None
    ax.set_ylabel('Average Precision', fontsize=fontsize)
    ax.tick_params(axis='both', labelsize=labelsize)
    ax.set_ylim((0.0, 105.0))
    ax.set_xlabel('\\# Digits in Test Image', fontsize=fontsize)
    ax.set_xticks([0, 5, 10, 15, 20])
    ax.legend(loc='lower left', fontsize=8)
    ax = axes[1]
    measure = '_test_count_1norm'
    nb0_data = get_transfer_data(yolo_path_n_lookback_0, 'n_train', measure, 'ci95')
    for ((x, y, *yerr), key) in nb0_data:
        if (not key_filter(key)):
            continue
        ax.errorbar(x, y, yerr=yerr)
    nb1_data = get_transfer_data(yolo_path_n_lookback_1, 'n_train', measure, 'ci95')
    for ((x, y, *yerr), key) in nb1_data:
        if (not key_filter(key)):
            continue
        ax.errorbar(x, y, yerr=yerr)
    ax.set_ylabel('Count Absolute Error', fontsize=fontsize)
    ax.set_xlabel('\\# Digits in Test Image', fontsize=fontsize)
    ax.tick_params(axis='both', labelsize=labelsize)
    ax.set_ylim((0.0, 4.0))
    ax.set_xticks([0, 5, 10, 15, 20])
    ax = axes[2]
    measure = '_test_count_error'
    nb0_data = get_transfer_data(yolo_path_n_lookback_0, 'n_train', measure, 'ci95')
    for ((x, y, *yerr), key) in nb0_data:
        if (not key_filter(key)):
            continue
        ax.errorbar(x, y, yerr=yerr)
    nb1_data = get_transfer_data(yolo_path_n_lookback_1, 'n_train', measure, 'ci95')
    for ((x, y, *yerr), key) in nb1_data:
        if (not key_filter(key)):
            continue
        ax.errorbar(x, y, yerr=yerr)
    ax.set_ylabel('Count 0-1 Error', fontsize=fontsize)
    ax.tick_params(axis='both', labelsize=labelsize)
    ax.set_ylim((0.0, 1.05))
    ax.set_xlabel('\\# Digits in Test Image', fontsize=fontsize)
    ax.set_xticks([0, 5, 10, 15, 20])
    plt.subplots_adjust(left=0.07, bottom=0.2, right=0.98, top=0.94, wspace=0.27)
    plot_path = os.path.join(plot_dir, ('ablation/main.' + extension))
    os.makedirs(os.path.dirname(plot_path), exist_ok=True)
    fig.savefig(plot_path)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
 = plt.subplots

idx = 6:------------------- similar code ------------------ index = 40, score = 6.0 
def plot_masks(nrows, ncols, generation_order, masks, k=3, out_path=None):
    import time
    (fig, axes) = plt.subplots(nrows, ncols)
    plt.suptitle(f'Kernel masks')
    for (row_major_index, ((r, c), mask)) in enumerate(zip(generation_order, masks)):
        axes[((row_major_index // ncols), (row_major_index % ncols))].imshow(mask, vmin=0, vmax=1)
    plt.setp(axes, xticks=[], yticks=[])
    if out_path:
        plt.savefig(out_path)
    else:
        plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 7:------------------- similar code ------------------ index = 39, score = 6.0 
def draw_r0_daily_evolution(stats_arg, show_plot, x_tick=10):
    (fig, ax) = plt.subplots(figsize=(15, 10))
    set_ax_r0(ax, stats_arg['R0d'], 'R0 Daily', x_tick=10)
    if show_plot:
        plt.show()
    else:
        plt.savefig(('images/output/%d-R0-daily-%d-%d.png' % (ts, stats_arg['hea'].shape[0], np.max(stats_arg['hea']))))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 8:------------------- similar code ------------------ index = 38, score = 6.0 
def table_box_plot(setting, landmarks, compare_list=None, fig_measure_list=None, plot_per_pair=False, fig_ext='.png', plot_folder=None, paper_table=None, naming_strategy=None, jacobian=False, multi_jac_exp_list=None):
    "\n    merge the landmarks from different cases\n    :param setting:\n    :param landmarks:\n    :param compare_list:\n    :param\n    :param plot_folder: one of the experiment to save all plots in that directory. The plot folder should consider also the stages\n    for example: my_experiment_S4_S2_S1. if None, the last experiment will be chosen as the plot folder\n    :param naming_strategy: None\n                            'Fancy'\n                            'Clean'\n    :param paper_table: 'SPREAD', 'DIR-Lab'\n    :return:\n    "
    if (multi_jac_exp_list is None):
        if (paper_table == 'SPREAD-Multi'):
            multi_jac_exp_list = ['2020_multistage_crop45_K_NoResp_SingleOnly_more_itr_S4_S2_S1', 'BSpline_S4_S2_S1']
            multi_jac_exp_list = []
        if (paper_table == 'DIR-Lab-Multi'):
            multi_jac_exp_list = ['2020_multistage_crop45_K_Resp_more_itr_S4_S2_S1']
    if (compare_list is None):
        compare_list = ['Affine', 'BSpline']
    if (fig_measure_list is None):
        fig_measure_list = ['TRE']
    landmarks_merged = dict()
    if (plot_folder is None):
        plot_key = list(landmarks.items())[(- 1)][0]
    else:
        plot_key = plot_folder
    split_plot_folder = plot_key.split('_S')
    stage_list = []
    plot_folder_key_pure = split_plot_folder[0]
    for split_str in split_plot_folder:
        if (len(split_str) == 1):
            stage_list.append(int(split_str))
    result_folder = su.address_generator(setting, 'result_detail_folder', current_experiment=plot_folder_key_pure, stage_list=stage_list, pair_info=landmarks[plot_key][0]['pair_info'])
    if (not os.path.isdir(result_folder)):
        os.makedirs(result_folder)
    xlsx_address = (result_folder + 'results.xlsx')
    workbook = xlsxwriter.Workbook(xlsx_address)
    worksheet = workbook.add_worksheet()
    line = 0
    header = {'exp': 0, 'TRE_Mean': 1, 'TRE_STD': 2, 'TRE_Median': 3, 'MAE0_Mean': 4, 'MAE0_STD': 5, 'MAE1_Mean': 6, 'MAE1_STD': 7, 'MAE2_Mean': 8, 'MAE2_STD': 9, 'Jac_FoldingPercentage': 10, 'Jac_STD': 11, 'Error0_Mean': 12, 'Error0_STD': 13, 'Error1_Mean': 14, 'Error1_STD': 15, 'Error2_Mean': 16, 'Error2_STD': 17}
    for key in header.keys():
        worksheet.write(line, header[key], key)
    num_exp = len(landmarks.keys())
    for (exp_i, exp) in enumerate(landmarks.keys()):
        landmarks_merged[exp] = {'TRE': np.empty([0]), 'Error': np.empty([0, 3]), 'CleanName': su.clean_exp_name(exp), 'FancyName': su.fancy_exp_name(exp), 'Jac_NumberOfNegativeJacVoxels': 0, 'Jac_MaskSize': 0, 'Jac_Var': 0, 'Jac_STD_List': [], 'Jac_FoldingPercentage_List': []}
        num_pair = len(landmarks[exp])
        for (pair_i, landmark_pair) in enumerate(landmarks[exp]):
            pair_info = landmark_pair['pair_info']
            pair_info_text = ((((((landmarks_merged[exp]['CleanName'] + '_Fixed_') + pair_info[0]['data']) + '_CN{}_TypeIm{},'.format(pair_info[0]['cn'], pair_info[0]['type_im'])) + '_Moving_') + pair_info[1]['data']) + '_CN{}_TypeIm{}'.format(pair_info[1]['cn'], pair_info[1]['type_im']))
            landmarks_merged[exp]['TRE'] = np.append(landmarks_merged[exp]['TRE'], landmark_pair['landmark_info']['TRE'])
            landmarks_merged[exp]['Error'] = np.vstack((landmarks_merged[exp]['Error'], landmark_pair['landmark_info']['Error']))
            if jacobian:
                if (paper_table is not None):
                    if (exp in multi_jac_exp_list):
                        landmarks_merged[exp]['Jac_NumberOfNegativeJacVoxels'] += landmark_pair['landmark_info']['Jac_NumberOfNegativeJacVoxels']
                        landmarks_merged[exp]['Jac_MaskSize'] += landmark_pair['landmark_info']['Jac_MaskSize']
                        landmarks_merged[exp]['Jac_Var'] += ((landmark_pair['landmark_info']['Jac_Var'] * 1) / len(landmarks[exp]))
                        landmarks_merged[exp]['Jac_STD_List'].append(np.sqrt(landmark_pair['landmark_info']['Jac_Var']))
                        landmarks_merged[exp]['Jac_FoldingPercentage_List'].append(((landmark_pair['landmark_info']['Jac_NumberOfNegativeJacVoxels'] / landmark_pair['landmark_info']['Jac_MaskSize']) * 100))
            measure = calculate_measure(landmark_pair['landmark_info'])
            measure['exp'] = pair_info_text
            if plot_per_pair:
                print_latex(measure)
            line = ((exp_i + (pair_i * (num_exp + 1))) + 1)
            for key in header.keys():
                if (key in measure.keys()):
                    worksheet.write(line, header[key], measure[key])
                    landmark_pair['landmark_info'][key] = measure[key]
        measure_merged = calculate_measure(landmarks_merged[exp])
        if (naming_strategy == 'Clean'):
            measure_merged['exp'] = su.clean_exp_name(exp)
        elif (naming_strategy == 'Fancy'):
            measure_merged['exp'] = su.fancy_exp_name(exp)
        else:
            measure_merged['exp'] = exp
        print_latex(measure_merged)
        line = ((exp_i + (num_pair * (num_exp + 1))) + 2)
        for key in header.keys():
            if (key in measure.keys()):
                if ((key in header.keys()) and (key in measure_merged.keys())):
                    worksheet.write(line, header[key], measure_merged[key])
    workbook.close()
    if (paper_table == 'SPREAD'):
        print_latex_spread(landmarks, landmarks_merged, plot_key)
    if (paper_table == 'DIR-Lab'):
        print_latex_dir_lab_4d(landmarks, landmarks_merged, plot_key)
    if (paper_table == 'SPREAD-Multi'):
        print_latex_spread_multiple(landmarks, landmarks_merged, multi_jac_exp_list)
    if (paper_table == 'DIR-Lab-Multi'):
        print_latex_dir_lab_4d_multiple(landmarks, landmarks_merged, multi_jac_exp_list)
    for measure in fig_measure_list:
        if plot_per_pair:
            for pair_i in range(len(landmarks[next(iter(landmarks))])):
                (fig, ax) = plt.subplots(figsize=(15, 8))
                bplot1 = plt.boxplot([landmarks[exp][pair_i]['landmark_info'][measure] for exp in landmarks.keys()], patch_artist=True, notch=True)
                title_name = landmarks[next(iter(landmarks))][pair_i]['landmark_info']['exp']
                plt.title(title_name)
                plt.draw()
                plt.savefig(((((result_folder + measure) + '_') + title_name) + fig_ext))
                plt.close()
        (fig, ax) = plt.subplots(figsize=(15, 8))
        bplot1 = plt.boxplot([landmarks_merged[exp][measure] for exp in landmarks_merged.keys()], patch_artist=True, notch=True)
        title_name = (measure + '_Merged')
        plt.title(title_name)
        plt.savefig(((((result_folder + measure) + '_') + title_name) + fig_ext))
        plt.draw()
        plt.close()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    for  ...  in  ... :
        if  ... :
            for  ...  in:
 = plt.subplots

idx = 9:------------------- similar code ------------------ index = 74, score = 6.0 
if (__name__ == '__main__'):
    import os
    os.environ['CUDA_DEVICE_ORDER'] = 'PCI_BUS_ID'
    os.environ['CUDA_VISIBLE_DEVICES'] = ''
    x = tf.random.normal((4, 100, 100, 3))
    x = (x - tf.math.reduce_min(x))
    x = (x / tf.math.reduce_max(x))
    x_aug = transform(x)
    (fig, axes) = plt.subplots(4, 2)
    for b in range(4):
        img = x[b]
        img_aug = x_aug[b]
        axes[b][0].imshow(img)
        axes[b][1].imshow(img_aug)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
if:
 = plt.subplots

idx = 10:------------------- similar code ------------------ index = 36, score = 6.0 
def plot(self, marker=''):
    (fig, ax) = plt.subplots()
    ax.set_aspect('equal')
    for state in self.trajectory:
        plt.plot(state[0], state[1], marker=marker, color='black')
    plt.gca().axes.xaxis.set_ticklabels([])
    plt.gca().axes.yaxis.set_ticklabels([])
    plt.xticks([])
    plt.yticks([])
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots()

idx = 11:------------------- similar code ------------------ index = 35, score = 6.0 
def draw_meta_simulation(death_stat_arg, show_plot):
    (fig, ax) = plt.subplots(figsize=(15, 10))
    set_ax_meta_simulation(ax, death_stat_arg)
    if show_plot:
        plt.show()
    else:
        plt.savefig(('images/output/%d-meta-%d-%d.png' % (ts, death_stat_arg['dea'].shape[0], np.max(death_stat_arg['dea']))))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 12:------------------- similar code ------------------ index = 34, score = 6.0 
def get_equity_data():
    'Displays a pie chart of your portfolio holdings\n    '
    holdings_data = r.build_holdings()
    equity_data = {}
    for (key, value) in holdings_data.items():
        equity_data[key] = {}
        equity_data[key][name] = value.get('name')
        equity_data[key][percentage] = value.get('percentage')
        equity_data[key][type]
    (fig1, ax1) = plt.subplots()
    ax1.pie(equities, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)
    ax1.axis('equal')
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots()

idx = 13:------------------- similar code ------------------ index = 33, score = 6.0 
def create_graph_midpoints(G_, linestring_delta=50, is_curved_eps=0.03, n_id_add_val=1, allow_renaming=True, figsize=(0, 0), verbose=False, super_verbose=False):
    "\n    Insert midpoint nodes into long edges on the graph.\n\n    Arguments\n    ---------\n    G_ : networkx graph\n        Input networkx graph, with edges assumed to have a dictioary of\n        properties that includes the 'geometry' key.\n    linestring_delta : float\n        Distance in meters between linestring midpoints. Defaults to ``50``.\n    is_curved_eps : float\n        Minumum curvature for injecting nodes (if curvature is less than this\n        value, no midpoints will be injected). If < 0, always inject points\n        on line, regardless of curvature.  Defaults to ``0.3``.\n    n_id_add_val : int\n        Sets min midpoint id above existing nodes\n        e.g.: G.nodes() = [1,2,4], if n_id_add_val = 5, midpoints will\n        be [9,10,11,...]\n    allow_renameing : boolean\n        Switch to allow renaming of an existing node with node_id if the\n        existing node is closest to the point. Defaults to ``False``.\n    figsize : tuple\n        Figure size for optional plot. Defaults to ``(0,0)`` (no plot).\n    verbose : boolean\n        Switch to print relevant values to screen.  Defaults to ``False``.\n    super_verbose : boolean\n        Switch to print mucho values to screen.  Defaults to ``False``.\n\n    Returns\n    -------\n    Gout, xms, yms : tuple\n        Gout is the updated graph\n        xms, yms are coordinates of the inserted points\n    "
    if (len(G_.nodes()) == 0):
        return (G_, [], [])
    (xms, yms) = ([], [])
    Gout = G_.copy()
    (midpoint_name_val, midpoint_name_inc) = ((np.max(G_.nodes()) + n_id_add_val), 1)
    for (u, v, data) in G_.edges(data=True):
        if ('geometry' in data):
            edge_props_init = G_.edges([u, v])
            linelen = data['length']
            line = data['geometry']
            (xs, ys) = line.xy
            (minx, miny, maxx, maxy) = line.bounds
            dst = scipy.spatial.distance.euclidean([minx, miny], [maxx, maxy])
            if ((np.abs((dst - linelen)) / linelen) < is_curved_eps):
                continue
            if (linelen < (0.75 * linestring_delta)):
                continue
            if verbose:
                print('create_graph_midpoints()...')
                print('  u,v:', u, v)
                print('  data:', data)
                print('  edge_props_init:', edge_props_init)
            if (linelen <= linestring_delta):
                interp_dists = [(0.5 * line.length)]
            else:
                npoints = (len(np.arange(0, linelen, linestring_delta)) + 1)
                interp_dists = np.linspace(0, linelen, npoints)[1:(- 1)]
                if verbose:
                    print('  interp_dists:', interp_dists)
            node_id_new_list = []
            (xms_tmp, yms_tmp) = ([], [])
            for (j, d) in enumerate(interp_dists):
                if verbose:
                    print('    ', j, 'interp_dist:', d)
                midPoint = line.interpolate(d)
                (xm0, ym0) = midPoint.xy
                xm = xm0[(- 1)]
                ym = ym0[(- 1)]
                point = Point(xm, ym)
                xms.append(xm)
                yms.append(ym)
                xms_tmp.append(xm)
                yms_tmp.append(ym)
                if verbose:
                    print('    midpoint:', xm, ym)
                node_id = midpoint_name_val
                midpoint_name_val += midpoint_name_inc
                node_id_new_list.append(node_id)
                if verbose:
                    print('    node_id:', node_id)
                (Gout, node_props, _, _) = insert_point_into_G(Gout, point, node_id=node_id, allow_renaming=allow_renaming, verbose=super_verbose)
        if (figsize != (0, 0)):
            (fig, ax) = plt.subplots(1, 1, figsize=((1 * figsize[0]), figsize[1]))
            ax.plot(xs, ys, color='#6699cc', alpha=0.7, linewidth=3, solid_capstyle='round', zorder=2)
            ax.scatter(xm, ym, color='red')
            ax.set_title('Line Midpoint')
            plt.axis('equal')
    return (Gout, xms, yms)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    for in:
        if:
 = plt.subplots

idx = 14:------------------- similar code ------------------ index = 30, score = 6.0 
def draw_summary(stats_arg, show_plot, x_tick=10):
    (fig, (ax1, ax2, ax3)) = plt.subplots(3, 1, figsize=(16, 10))
    set_ax_mean_population_state_daily(ax1, stats_arg, x_tick)
    set_ax_new_daily_cases(ax2, stats_arg, x_tick)
    set_ax_specific_population_state_daily(ax3, stats_arg, x_tick)
    ax1.set_xlabel('')
    ax2.set_xlabel('')
    ax2.set_title('')
    ax3.set_title('')
    if show_plot:
        plt.show()
    else:
        plt.savefig(('images/output/%d-summ-%d-%d.png' % (ts, stats_arg['hea'].shape[0], np.max(stats_arg['hea']))))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 15:------------------- similar code ------------------ index = 26, score = 6.0 
def plot_depth_hist(depths, n_bins=100):
    (fig, axs) = plt.subplots(1, depths.shape[0], sharey=True, tight_layout=True)
    for (i, ax) in enumerate(axs):
        ax.hist(depths[i], bins=n_bins)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 16:------------------- similar code ------------------ index = 25, score = 6.0 
def plot_schedules(sol_file_name):
    plot_file_name = (sol_file_name[0:sol_file_name.rfind('.json')] + '_gantt.svg')
    print(('Parsing ' + sol_file_name))
    with open(sol_file_name, 'r') as sol_file:
        solution = json.load(sol_file)
    (fig, ax1) = plt.subplots(1, 1)
    fig.set_figwidth(15)
    plt.subplots_adjust(left=0.03, right=1, top=1, bottom=0.05, wspace=0.03)
    if ('routes' not in solution):
        return
    n = len(solution['routes'])
    i = 0
    for route in solution['routes']:
        color = color_list[(route['vehicle'] % len(color_list))]
        t = route['steps'][0]['arrival']
        (d1, d2) = (0, 0)
        for step in route['steps']:
            (d1, d2) = (d2, step['duration'])
            dt = (d2 - d1)
            ax1.hlines(y=i, xmin=t, xmax=(t + dt), colors=color)
            t += dt
            dt = step['waiting_time']
            t += dt
            dt = step['setup']
            ax1.hlines(y=i, xmin=t, xmax=(t + dt), colors=color, linewidth=5)
            t += dt
            dt = step['service']
            if (step['type'] in ['job', 'pickup', 'delivery']):
                ax1.vlines(x=t, ymin=((i - 0.5) + (5 / (n + 10))), ymax=((i + 0.5) - (5 / (n + 10))), colors=color)
                ax1.hlines(y=i, xmin=t, xmax=(t + dt), colors=color, linewidth=5)
            elif (step['type'] == 'break'):
                ax1.hlines(y=i, xmin=t, xmax=(t + dt), colors=color, linestyle='dashed')
            t += dt
        i += 1
    computing_time = solution['summary']['computing_times']['loading']
    computing_time += solution['summary']['computing_times']['solving']
    if ('routing' in solution['summary']['computing_times']):
        computing_time += solution['summary']['computing_times']['routing']
    title = plot_file_name[:plot_file_name.rfind('.')]
    title += (' ; cost: ' + str(solution['summary']['cost']))
    title += (' ; computing time: ' + str(computing_time))
    title += 'ms'
    ax1.set_title(title)
    print(('Plotting file ' + plot_file_name))
    plt.savefig(plot_file_name, bbox_inches='tight')
    plt.close()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
 = plt.subplots

idx = 17:------------------- similar code ------------------ index = 23, score = 6.0 
def figure_plot(steer_pred1, steer_pred2, steer_gt, iteration):
    (fig, ax) = plt.subplots(figsize=(16, 7))
    time_vec = range(0, len(steer_pred1))
    time_vec = [((float(x) / 10.0) + 200) for x in time_vec]
    ax.plot(time_vec, steer_pred1, 'g', label='Model 2')
    ax.plot(time_vec, steer_pred2, 'r', label='Model 1')
    ax.plot(time_vec, steer_gt, 'b', label='Ground Truth')
    ax.set_ylim([(- 0.6), 0.8])
    ax.set_xlim([200, 650])
    for item in (([ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels()) + ax.get_yticklabels()):
        item.set_fontsize(24)
    ax.legend(loc='upper center', ncol=3)
    ax.set_xlabel('Time (seconds)')
    ax.set_ylabel('Steering Value (radians)')
    fig.savefig((('footage_offline/plot' + str(iteration)) + '.png'), orientation='landscape', bbox_inches='tight')
    plt.close(fig)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 18:------------------- similar code ------------------ index = 22, score = 6.0 
def animate_network(trajectory, save=False, interval=50, dpi=80, layout='shell', with_labels=True, with_arrows=True, node_color='b', node_size=30, with_timestep=False, show=True):
    (fig, ax) = plt.subplots()

    def update(arg):
        ax.clear()
        (i, state) = arg
        if with_timestep:
            ax.set_title(('timestep: %s' % (i + 1)))
        color = (node_color[i] if (type(node_color) == dict) else node_color)
        network = state.network
        G = nx.MultiDiGraph()
        for n in network.nodes:
            G.add_node(n)
        for edge in network.edges:
            G.add_edge(edge[0], edge[1])
        state_layout = (layout[i] if ((type(layout) == list) or (type(layout) == tuple)) else layout)
        if (state_layout == 'shell'):
            nx.draw_shell(G, with_labels=with_labels, node_color=color, node_size=node_size, arrows=with_arrows)
        elif (state_layout == 'spring'):
            nx.draw_spring(G, with_labels=with_labels, node_color=color, node_size=node_size, arrows=with_arrows)
        elif (state_layout == 'planar'):
            nx.draw_planar(G, with_labels=with_labels, node_color=color, node_size=node_size, arrows=with_arrows)
        elif (state_layout == 'kamada-kawai'):
            nx.draw_kamada_kawai(G, with_labels=with_labels, node_color=color, node_size=node_size, arrows=with_arrows)
        elif isinstance(state_layout, dict):
            nx.draw(G, pos=state_layout, with_labels=with_labels, node_color=color, node_size=node_size, arrows=with_arrows)
        else:
            raise Exception(('unsupported layout: %s' % state_layout))
    ani = animation.FuncAnimation(fig, update, frames=list(enumerate(trajectory)), interval=interval, save_count=len(trajectory))
    if save:
        ani.save('evolved.gif', dpi=dpi, writer='imagemagick')
    if show:
        plt.show()
    return ani

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots()


idx = 19:------------------- similar code ------------------ index = 18, score = 6.0 
def animate(self, save=False, interval=50, dpi=80, marker='', repeat=False, fps=50):
    (fig, ax) = plt.subplots()
    ax.set_aspect('equal')
    x_vals = [s[0] for s in self.trajectory]
    max_x = np.max(x_vals)
    min_x = np.min(x_vals)
    max_x += (0.05 * (max_x - min_x))
    min_x -= (0.05 * (max_x - min_x))
    y_vals = [s[1] for s in self.trajectory]
    max_y = np.max(y_vals)
    min_y = np.min(y_vals)
    max_y += (0.05 * (max_y - min_y))
    min_y -= (0.05 * (max_y - min_y))

    def update(t):
        plt.plot(self.trajectory[t][0], self.trajectory[t][1], marker=marker, color='black')
        if ((t == (len(self.trajectory) - 1)) and repeat):
            ax.clear()
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.set_xticks([])
            ax.set_yticks([])
            plt.xlim(min_x, max_x)
            plt.ylim(min_y, max_y)
    ani = animation.FuncAnimation(fig, update, frames=len(self.trajectory), interval=interval, save_count=len(self.trajectory), repeat=repeat)
    plt.xlim(min_x, max_x)
    plt.ylim(min_y, max_y)
    plt.gca().axes.xaxis.set_ticklabels([])
    plt.gca().axes.yaxis.set_ticklabels([])
    plt.xticks([])
    plt.yticks([])
    if save:
        ani.save('turtle.gif', dpi=dpi, writer='imagemagick', fps=fps)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots()

idx = 20:------------------- similar code ------------------ index = 17, score = 6.0 
def plot_analysis(all_metrics, plot_param, out_file=None):
    if ('Regularization' in plot_param['title']):
        model_to_legend = {'25_nor_no_single_ctrl_bal_regr_all': 'No regularization', '25_nor_ndrop_single_ctrl_bal_regr_all': 'Dropout', '25_nor_saug_single_ctrl_bal_regr_all': 'Dropout + mild aug.', '25_nor_maug_single_ctrl_bal_regr_all': 'Dropout + heavy aug.'}
        model_to_id = {'25_nor_no_single_ctrl_bal_regr_all': 1, '25_nor_ndrop_single_ctrl_bal_regr_all': 2, '25_nor_saug_single_ctrl_bal_regr_all': 3, '25_nor_maug_single_ctrl_bal_regr_all': 4}
    elif ('Data distribution' in plot_param['title']):
        model_to_legend = {'25_nor_ndrop_single_ctrl_bal_regr_all': 'Three cameras with noise', '25_nor_ndrop_single_ctrl_bal_regr_jcen': 'Central camera with noise', '25_nor_ndrop_single_ctrl_bal_regr_nnjc': 'Central camera, no noise', '25_nor_ndrop_single_ctrl_seq_regr_all': 'Three cameras with noise, no balancing'}
        model_to_id = {'25_nor_ndrop_single_ctrl_bal_regr_nnjc': 1, '25_nor_ndrop_single_ctrl_bal_regr_jcen': 2, '25_nor_ndrop_single_ctrl_bal_regr_all': 3, '25_nor_ndrop_single_ctrl_seq_regr_all': 4}
    elif ('Model architecture' in plot_param['title']):
        model_to_legend = {'25_small_ndrop_single_ctrl_bal_regr_all': 'Shallow CNN', '25_nor_ndrop_single_ctrl_bal_regr_all': 'Standard CNN', '25_deep_ndrop_single_ctrl_bal_regr_all': 'Deep CNN', '25_nor_ndrop_lstm_ctrl_bal_regr_all': 'Standard LSTM'}
        model_to_id = {'25_small_ndrop_single_ctrl_bal_regr_all': 1, '25_nor_ndrop_single_ctrl_bal_regr_all': 2, '25_deep_ndrop_single_ctrl_bal_regr_all': 3, '25_nor_ndrop_lstm_ctrl_bal_regr_all': 4}
    else:
        model_to_legend = {'1_nor_maug_single_ctrl_bal_regr_all': '1 hour', '5_nor_maug_single_ctrl_bal_regr_all': '5 hours', '25_nor_maug_single_ctrl_bal_regr_all': '25 hours', '80_nor_maug_single_ctrl_bal_regr_all': '80 hours'}
        model_to_id = {'1_nor_maug_single_ctrl_bal_regr_all': 1, '5_nor_maug_single_ctrl_bal_regr_all': 2, '25_nor_maug_single_ctrl_bal_regr_all': 3, '80_nor_maug_single_ctrl_bal_regr_all': 4}
    town_to_legend = {'Town01_1': 'Town 1', 'Town02_14': 'Town 2'}
    town_to_id = {'Town01_1': 1, 'Town02_14': 2}

    def exp_to_legend_and_idx(exp):
        legend = exp
        idx = []
        for model in model_to_legend:
            if exp.startswith(model):
                legend = legend.replace(model, model_to_legend[model])
                idx.append(model_to_id[model])
                break
        for town in town_to_legend:
            if exp.endswith(town):
                legend = legend.replace(town, town_to_legend[town])
                idx.append(town_to_id[town])
                break
        legend = legend.replace('_', ', ')
        return (legend, idx)
    (fig, ax) = plt.subplots(figsize=(8, 8))
    plt.set_cmap('jet')
    cm = plt.get_cmap()
    c_norm = colors.Normalize(vmin=0, vmax=50)
    scalar_map = cmx.ScalarMappable(norm=c_norm, cmap=cm)
    plt.rc('font', size=16)
    plt.rc('axes', titlesize=16)
    plt.rc('axes', labelsize=20)
    plt.rc('xtick', labelsize=16)
    plt.rc('ytick', labelsize=16)
    plt.rc('legend', fontsize=14)
    plt.rc('figure', titlesize=16)
    print((np.log(plot_param['x_lim']) if plot_param['x']['log'] else plot_param['x_lim']))
    ax.set_xlim(((np.log(plot_param['x_lim']) / np.log(10.0)) if plot_param['x']['log'] else plot_param['x_lim']))
    ax.set_ylim(((np.log(plot_param['y_lim']) / np.log(10.0)) if plot_param['y']['log'] else plot_param['y_lim']))
    plt.locator_params(axis='x', nbins=4)
    plt.locator_params(axis='y', nbins=8)
    x_label = 'Steering error'
    y_label = 'Success rate'
    if plot_param['x']['log']:
        x_label += ' (log)'
        ax.set_xticklabels([('%.1e' % np.power(10, float(t))) for t in ax.get_xticks()])
    if plot_param['y']['log']:
        y_label += ' (log)'
        ax.set_yticklabels([('%.1e' % np.power(10, float(t))) for t in ax.get_yticks()])
    ax.set_xlabel(x_label)
    ax.set_ylabel(y_label)
    scatter_handles = {}
    for (experiment, metrics) in all_metrics.items():
        print(experiment)
        data = {'x': [], 'y': [], 'size': [], 'color': []}
        for key in data:
            data[key] = np.array(metrics[plot_param[key]['data']])
        nans = np.logical_or.reduce((np.isnan(data['x']), np.isnan(data['y']), np.isinf(data['x']), np.isinf(data['y'])))
        print(('\n ** Removing %d NaNs and infs before log **' % np.sum(nans)))
        for key in data:
            data[key] = data[key][np.invert(nans)]
        data_x = ((np.log(data['x']) / np.log(10)) if plot_param['x']['log'] else np.copy(data['x']))
        data_y = ((np.log(data['y']) / np.log(10)) if plot_param['y']['log'] else np.copy(data['y']))
        nans = np.logical_or.reduce((np.isnan(data_x), np.isnan(data_y), np.isinf(data_x), np.isinf(data_y)))
        print(('\n ** Removing %d NaNs and infs after log **' % np.sum(nans)))
        for key in data:
            data[key] = data[key][np.invert(nans)]
        data_x = data_x[np.invert(nans)]
        data_y = data_y[np.invert(nans)]
        color_val = scalar_map.to_rgba((hash(experiment) % 50))
        color_vec = ([color_val] * len(data_x))
        scatter_handles[experiment] = ax.scatter(data_x, data_y, s=data['size'], c=color_vec, alpha=0.5)
        ax.plot(data_x, data_y, color=color_val)
    sorted_keys = sorted(scatter_handles.keys(), key=(lambda x: exp_to_legend_and_idx(x)[1]))
    ax.legend([scatter_handles[k] for k in sorted_keys], [exp_to_legend_and_idx(k)[0] for k in sorted_keys])
    plt.title(plot_param['title'])
    if plot_param['print']:
        fig.savefig(out_file, bbox_inches='tight')

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 21:------------------- similar code ------------------ index = 16, score = 6.0 
def _plot_gt_prop_graphs(G_gt, G_prop, im_test_file, figsize=(16, 8), show_endnodes=False, width_key='Inferred Speed (mph)', width_mult=0.125, gt_color='cyan', prop_color='lime', default_node_size=15, title='', figname='', adjust=True, verbose=False):
    'Plot the ground truth, and prediction mask Overlay graph on image,\n    if width_key == int, use a constant width'
    (fig, (ax0, ax1)) = plt.subplots(1, 2, figsize=figsize)
    print('Plotting ground truth...')
    _ = plot_graph_on_im(G_gt, im_test_file, figsize=figsize, show_endnodes=show_endnodes, width_key=width_key, width_mult=width_mult, color=gt_color, default_node_size=default_node_size, title=('Ground Truth:  ' + title), figname='', ax=ax0, verbose=verbose)
    print('Plotting proposal...')
    _ = plot_graph_on_im(G_prop, im_test_file, figsize=figsize, show_endnodes=show_endnodes, width_key=width_key, width_mult=width_mult, color=prop_color, default_node_size=default_node_size, title=('Proposal:  ' + title), figname='', ax=ax1, verbose=verbose)
    plt.tight_layout()
    if adjust:
        plt.subplots_adjust(top=0.96)
    if figname:
        plt.savefig(figname, dpi=300)
    return fig

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 22:------------------- similar code ------------------ index = 14, score = 6.0 
if (__name__ == '__main__'):
    import os
    os.environ['CUDA_DEVICE_ORDER'] = 'PCI_BUS_ID'
    os.environ['CUDA_VISIBLE_DEVICES'] = ''
    img = imageio.imread('kitty.jpg')
    img = (tf.cast(img, tf.float32) / 255.0)
    imgs = tf.tile(img[tf.newaxis], [4, 1, 1, 1])
    channel = get_noisy_channel()
    for diff in tf.range(16):
        print(diff)
        x = channel(imgs, diff)
        (fig, axes) = plt.subplots(2, 2)
        x = (x - tf.math.reduce_min(x))
        x = (x / tf.math.reduce_max(x))
        axes[0][0].imshow(x[0])
        axes[0][1].imshow(x[1])
        axes[1][0].imshow(x[2])
        axes[1][1].imshow(x[3])
        plt.savefig(f'noise_{diff}.png')

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
if:
    for  ...  in:
 = plt.subplots

idx = 23:------------------- similar code ------------------ index = 12, score = 6.0 
def draw_new_daily_cases(stats_arg, show_plot, x_tick=10):
    (fig, ax) = plt.subplots(figsize=(15, 10))
    set_ax_new_daily_cases(ax, stats_arg, x_tick)
    if show_plot:
        plt.show()
    else:
        plt.savefig(('images/output/%d-new-%d-%d.png' % (ts, stats_arg['hea'].shape[0], np.max(stats_arg['hea']))))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 24:------------------- similar code ------------------ index = 11, score = 6.0 
def visualize(img, perturbations, levels, show):
    'Visualize all specified perturbations and levels for a given image.\n\n    Args:\n        img (Image): PIL image for which to plot perturbations\n        perturbations (dict): maps name (str) -> mapping function (function)\n        levels (list): list of each level (int) to plot\n        show (bool): whether to show the final figure\n\n    Returns:\n        (None)\n\n    '
    import matplotlib
    if (not show):
        matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    out_dir = Path('output')
    out_dir.mkdir(exist_ok=True, parents=True)
    if ('identity' in perturbations):
        perturbations = perturbations.copy()
        del perturbations['identity']
    (fig, ax) = plt.subplots(nrows=len(levels), ncols=len(perturbations), gridspec_kw={'wspace': 0, 'hspace': 0}, figsize=FIG_SIZE)
    names = sorted(list(perturbations.keys()))
    for (iname, name) in enumerate(names):
        print(('Generating visuals for "%s"...' % name))
        mapping_fn = perturbations[name]
        for (ilevel, level) in enumerate(levels):
            perturbed_img = mapping_fn(level, img)
            perturbed_img_name = ('%s_%d.png' % (name, level))
            perturbed_img.save((out_dir / perturbed_img_name))
            ax[(ilevel, iname)].imshow(perturbed_img)
            ax[(ilevel, iname)].set_yticklabels([])
            ax[(ilevel, iname)].set_xticklabels([])
            ax[(ilevel, iname)].tick_params(axis='both', which='both', length=0)
            if (not iname):
                ax[(ilevel, iname)].set_ylabel(('Level %d' % level), rotation=90, size='large')
            if (not ilevel):
                ax[(ilevel, iname)].set_title(name)
    if show:
        plt.show()
    plt.savefig((out_dir / 'visualization.png'))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 25:------------------- similar code ------------------ index = 9, score = 6.0 
def plot_image(images, name, shape=None, figsize=(10, 10)):
    images = [np.minimum(np.maximum(img, 0.0), 1.0) for img in images]
    images = channel_last(images, is_array=True)
    len_list = len(images)
    im_list = []
    for i in range(len_list):
        im_list.append(images[i])
    if (shape is None):
        unit = int((len_list ** 0.5))
        shape = (unit, unit)
    imshape = im_list[0].shape
    if (imshape[2] == 1):
        im_list = [np.repeat(im, 3, axis=2) for im in im_list]
    else:
        im_list = [im for im in im_list]
    (fig, axes) = plt.subplots(nrows=shape[1], ncols=shape[1], figsize=figsize)
    for (idx, image) in enumerate(im_list):
        row = (idx // shape[0])
        col = (idx % shape[1])
        axes[(row, col)].axis('off')
        axes[(row, col)].imshow(image, cmap='gray', aspect='auto')
    plt.subplots_adjust(wspace=0.05, hspace=0.05)
    plt.tight_layout()
    plt.savefig(name)
    plt.close(fig)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 26:------------------- similar code ------------------ index = 8, score = 6.0 
def _plot_reconstruction(self, updater, fetched):
    inp = fetched['inp']
    output = fetched['output']
    (_, image_height, image_width, _) = inp.shape
    obj = fetched['obj'].reshape(self.N, (- 1))
    anchor_box = updater.network.anchor_box
    (yt, xt, ys, xs) = np.split(fetched['normalized_box'], 4, axis=(- 1))
    (yt, xt, ys, xs) = coords_to_pixel_space(yt, xt, ys, xs, (image_height, image_width), anchor_box, top_left=True)
    box = np.concatenate([yt, xt, ys, xs], axis=(- 1))
    box = box.reshape(self.N, (- 1), 4)
    pred_colour = np.array(to_rgb(self.pred_colour))
    if self.do_annotations:
        n_annotations = fetched.get('n_annotations', ([0] * self.N))
        annotations = fetched.get('annotations', None)
        gt_colour = np.array(to_rgb(self.gt_colour))
    cutoff = 0.5
    for (n, (pred, gt)) in enumerate(zip(output, inp)):
        (fig, axes) = plt.subplots(1, 3, figsize=(6, 3))
        axes = np.array(axes).reshape(3)
        ax1 = axes[0]
        self.imshow(ax1, gt)
        ax2 = axes[1]
        self.imshow(ax2, pred)
        ax3 = axes[2]
        self.imshow(ax3, pred)
        for (o, (top, left, height, width)) in zip(obj[n], box[n]):
            if (o > cutoff):
                rect = patches.Rectangle((left, top), width, height, linewidth=2, edgecolor=pred_colour, facecolor='none')
                ax3.add_patch(rect)
        if self.do_annotations:
            for k in range(n_annotations[n]):
                (valid, _, _, top, bottom, left, right) = annotations[n][k]
                if (not valid):
                    continue
                height = (bottom - top)
                width = (right - left)
                rect = patches.Rectangle((left, top), width, height, linewidth=1, edgecolor=gt_colour, facecolor='none')
                ax3.add_patch(rect)
        for ax in axes.flatten():
            ax.set_axis_off()
        plt.subplots_adjust(left=0.02, right=0.98, top=0.98, bottom=0.02, wspace=0.1, hspace=0.1)
        self.savefig(('sampled_reconstruction/' + str(n)), fig, updater)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    for in:
 = plt.subplots

idx = 27:------------------- similar code ------------------ index = 6, score = 6.0 
def plot_graph_on_im(G_, im_test_file, figsize=(8, 8), show_endnodes=False, width_key='speed_m/s', width_mult=0.125, color='lime', title='', figname='', default_node_size=15, max_speeds_per_line=12, dpi=300, plt_save_quality=75, ax=None, verbose=False):
    '\n    Overlay graph on image,\n    if width_key == int, use a constant width'
    try:
        im_cv2 = cv2.imread(im_test_file, 1)
        img_mpl = cv2.cvtColor(im_cv2, cv2.COLOR_BGR2RGB)
    except:
        img_sk = skimage.io.imread(im_test_file)
        if ((len(img_sk.shape) == 3) and (img_sk.shape[0] < 20)):
            img_mpl = np.moveaxis(img_sk, 0, (- 1))
        else:
            img_mpl = img_sk
    (h, w) = img_mpl.shape[:2]
    (node_x, node_y, lines, widths, title_vals) = ([], [], [], [], [])
    for (i, (u, v, edge_data)) in enumerate(G_.edges(data=True)):
        if (type(edge_data['geometry_pix']) == str):
            coords = list(shapely.wkt.loads(edge_data['geometry_pix']).coords)
        else:
            coords = list(edge_data['geometry_pix'].coords)
        if verbose:
            print('\n', i, u, v, edge_data)
            print('edge_data:', edge_data)
            print('  coords:', coords)
        lines.append(coords)
        node_x.append(coords[0][0])
        node_x.append(coords[(- 1)][0])
        node_y.append(coords[0][1])
        node_y.append(coords[(- 1)][1])
        if (type(width_key) == str):
            if verbose:
                print('edge_data[width_key]:', edge_data[width_key])
            width = int(np.rint((edge_data[width_key] * width_mult)))
            title_vals.append(int(np.rint(edge_data[width_key])))
        else:
            width = width_key
        widths.append(width)
    if (not ax):
        (fig, ax) = plt.subplots(1, 1, figsize=figsize)
    ax.imshow(img_mpl)
    if show_endnodes:
        ax.scatter(node_x, node_y, color=color, s=default_node_size, alpha=0.5)
    lc = mpl_collections.LineCollection(lines, colors=color, linewidths=widths, alpha=0.4, zorder=2)
    ax.add_collection(lc)
    ax.axis('off')
    if (len(title_vals) > 0):
        if verbose:
            print('title_vals:', title_vals)
        title_strs = np.sort(np.unique(title_vals)).astype(str)
        if (len(title_strs) > max_speeds_per_line):
            (n, b) = (max_speeds_per_line, title_strs)
            title_strs = np.insert(b, range(n, len(b), n), '\n')
        if verbose:
            print('title_strs:', title_strs)
        title = ((((title + '\n') + width_key) + ' = ') + ' '.join(title_strs))
    if title:
        ax.set_title(title)
    plt.tight_layout()
    print('title:', title)
    if title:
        plt.subplots_adjust(top=0.96)
    if verbose:
        print('img_mpl.shape:', img_mpl.shape)
    desired_dpi = int((np.max(img_mpl.shape) / np.max(figsize)))
    if verbose:
        print('desired dpi:', desired_dpi)
    dpi = int(np.min([3500, desired_dpi]))
    if verbose:
        print('plot dpi:', dpi)
    if figname:
        plt.savefig(figname, dpi=dpi, quality=plt_save_quality)
    return ax

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    if:
 = plt.subplots

idx = 28:------------------- similar code ------------------ index = 5, score = 6.0 
def plot_pareto_front(indicators, pareto_plot_file, full_Y_scale=False):
    (fig, ax1) = plt.subplots(1, 1)
    plt.xlabel('Completion time')
    plt.ylabel('Cost')
    options = {'dichotomy': {'marker': '^', 'edgecolor': 'red', 'linewidth': 0.7}, 'backward_search': {'marker': 'o', 'edgecolor': 'blue', 'linewidth': 0.5}}
    ymax = indicators[0]['cost']
    for origin in ['backward_search', 'dichotomy']:
        costs = [i['cost'] for i in indicators if (i['origin'] == origin)]
        if (len(costs) == 0):
            continue
        completions = [i['completion'] for i in indicators if (i['origin'] == origin)]
        ymax = max(ymax, max(costs))
        ax1.scatter(completions, costs, facecolor='none', edgecolor=options[origin]['edgecolor'], marker=options[origin]['marker'], linewidth=options[origin]['linewidth'])
    if full_Y_scale:
        ax1.set_ylim(0, (ymax * 1.05))
    plt.savefig(pareto_plot_file, bbox_inches='tight')
    plt.close()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 29:------------------- similar code ------------------ index = 4, score = 6.0 
def plot(alignment, info, text, isKorean=True):
    (char_len, audio_len) = alignment.shape
    (fig, ax) = plt.subplots(figsize=((char_len / 5), 5))
    im = ax.imshow(alignment.T, aspect='auto', origin='lower', interpolation='none')
    xlabel = 'Encoder timestep'
    ylabel = 'Decoder timestep'
    if (info is not None):
        xlabel += '\n{}'.format(info)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    if text:
        if isKorean:
            jamo_text = j2hcj(h2j(normalize(text)))
        else:
            jamo_text = text
        pad = ([PAD] * ((char_len - len(jamo_text)) - 1))
        A = (([tok for tok in jamo_text] + [EOS]) + pad)
        A = [(x if (x != ' ') else '') for x in A]
        plt.xticks(range(char_len), A)
    if (text is not None):
        while True:
            if (text[(- 1)] in [EOS, PAD]):
                text = text[:(- 1)]
            else:
                break
        plt.title(text)
    plt.tight_layout()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 30:------------------- similar code ------------------ index = 3, score = 6.0 
def plot_masked_keypoints(X, mask, true_label, false_label):
    (fig, ax) = plt.subplots()
    ax.scatter(X[(mask, 0)], X[(mask, 1)], label=true_label, color='b', marker='.')
    ax.scatter(X[((~ mask), 0)], X[((~ mask), 1)], label=false_label, color='r', marker='.')
    ax.grid(True)
    ax.legend()
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots()

idx = 31:------------------- similar code ------------------ index = 2, score = 6.0 
def _plot_reconstruction(self, updater, fetched):
    inp = fetched['inp']
    output = fetched['output']
    prediction = fetched.get('prediction', None)
    targets = fetched.get('targets', None)
    sqrt_N = int(np.ceil(np.sqrt(self.N)))
    fig_height = 20
    fig_width = (4.5 * fig_height)
    (fig, axes) = plt.subplots(sqrt_N, (3 * sqrt_N), figsize=(fig_width, fig_height))
    for (n, (pred, gt)) in enumerate(zip(output, inp)):
        i = int((n / sqrt_N))
        j = int((n % sqrt_N))
        ax = axes[(i, (3 * j))]
        ax.set_axis_off()
        self.imshow(ax, gt)
        if (targets is not None):
            _target = targets[n]
            _prediction = prediction[n]
            title = 'target={}, prediction={}'.format(np.argmax(_target), np.argmax(_prediction))
            ax.set_title(title)
        ax = axes[(i, ((3 * j) + 1))]
        ax.set_axis_off()
        self.imshow(ax, pred)
        ax = axes[(i, ((3 * j) + 2))]
        ax.set_axis_off()
        diff = (np.abs((gt - pred)).sum(2) / 3)
        self.imshow(ax, diff)
    plt.subplots_adjust(left=0, right=1, top=0.9, bottom=0, wspace=0.1, hspace=0.2)
    self.savefig('sampled_reconstruction', fig, updater)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 32:------------------- similar code ------------------ index = 1, score = 6.0 
def main():
    print(f'Using strategy: {strategy}')
    with strategy.scope():

        def vision_only_predict(model, batch, difficulty, perceptor):
            all_losses = {}
            symbols = batch
            (predictions, imgs, aug_imgs) = model(symbols, difficulty)
            acc = tf.keras.metrics.categorical_accuracy(symbols, predictions)
            acc = tf.math.reduce_mean(acc)
            acc = {'symbols': acc}
            lfn = (tf.keras.losses.mean_squared_error if CFG['use_mse_loss'] else (lambda true, pred: tf.keras.losses.categorical_crossentropy(true, pred, label_smoothing=CFG['label_smoothing'])))
            recon_loss = tf.keras.losses.categorical_crossentropy(symbols, predictions)
            recon_loss = tf.math.reduce_sum(recon_loss)
            all_losses['reconstruction'] = recon_loss
            if CFG['use_perceptual_loss']:
                features = perceptor(imgs)
                percept_loss = perceptual_loss(features)
                all_losses['perceptual'] = percept_loss
            if CFG['use_spy']:
                (predictions_s, imgs_s, aug_imgs_s) = model(symbols, difficulty, spy_turn=True)
                acc_s = tf.keras.metrics.categorical_accuracy(symbols, predictions_s)
                acc_s = tf.math.reduce_mean(acc_s)
                acc['spy_symbols'] = acc_s
                spy_loss = lfn(symbols, predictions_s)
                spy_loss = tf.math.reduce_sum(spy_loss)
            for sub_model in model.layers:
                name = sub_model.name
                all_losses[name] = tf.math.reduce_sum(sub_model.losses)
            loss_sum = 0.0
            for loss_name in all_losses.keys():
                loss_sum += all_losses[loss_name]
            if CFG['use_spy']:
                all_losses['spy_reconstruction'] = spy_loss
                all_losses['spy_scaled'] = tf.math.exp((spy_loss * (- 1)))
                loss_sum += all_losses['spy_scaled']
            return (loss_sum, acc, all_losses)

        def graph_or_full_predict(model, batch, difficulty, perceptor):
            all_losses = {}
            if CFG['VISION']:
                (adj_pred, nf_pred, imgs, aug_imgs, _, _) = model(batch, difficulty)
                (spy_adj_pred, spy_nf_pred, _, _, _, _) = model(batch, difficulty, spy_turn=True)
                if CFG['use_perceptual_loss']:
                    features = perceptor(imgs)
                    percept_loss = perceptual_loss(features)
                    all_losses['perceptual'] = percept_loss
            else:
                (adj_pred, nf_pred) = model(batch, difficulty)
                (spy_adj_pred, spy_nf_pred) = model(batch, difficulty, spy_turn=True)
            (recon_loss, acc) = minimum_loss_permutation(batch['adj_labels'], batch['nf_labels'], adj_pred, nf_pred)
            all_losses['reconstruction'] = recon_loss
            (spy_loss, spy_acc) = minimum_loss_permutation(batch['adj_labels'], batch['nf_labels'], spy_adj_pred, spy_nf_pred)
            for key in spy_acc.keys():
                acc[f'spy_{key}'] = spy_acc[key]
            for sub_model in model.layers:
                name = sub_model.name
                all_losses[name] = tf.math.reduce_sum(sub_model.losses)
            loss_sum = 0.0
            for loss_name in all_losses.keys():
                loss_sum += all_losses[loss_name]
            if CFG['use_spy']:
                all_losses['spy_reconstruction'] = spy_loss
                all_losses['spy_scaled'] = tf.math.exp((spy_loss * (- 1)))
                loss_sum += all_losses['spy_scaled']
            return (loss_sum, acc, all_losses)

        def predict(model, batch, difficulty, perceptor):
            if CFG['JUST_VISION']:
                (loss_sum, acc, all_losses) = vision_only_predict(model, batch, difficulty, perceptor)
            else:
                (loss_sum, acc, all_losses) = graph_or_full_predict(model, batch, difficulty, perceptor)
            return (loss_sum, acc, all_losses)

        @tf.function
        def train_step(batch, difficulty):
            with tf.GradientTape(persistent=True) as tape:
                (loss_sum, acc, all_losses) = predict(model, batch, difficulty, perceptor)
            grads = tape.gradient(loss_sum, model.trainable_variables)
            if CFG['TPU']:
                replica_ctx = tf.distribute.get_replica_context()
                grads = replica_ctx.all_reduce('mean', grads)
            optim.apply_gradients(zip(grads, model.trainable_variables))
            if CFG['use_spy']:
                spy_grads = tape.gradient(all_losses['spy_reconstruction'], model.spy.trainable_variables)
                if CFG['TPU']:
                    replica_ctx = tf.distribute.get_replica_context()
                    spy_grads = replica_ctx.all_reduce('mean', spy_grads)
                spy_optim.apply_gradients(zip(spy_grads, model.spy.trainable_variables))
            return (loss_sum, acc, all_losses)

        @tf.function
        def test_step(batch, difficulty):
            (batch_loss, acc, all_losses) = predict(model, batch, difficulty, perceptor)
            return (batch_loss, acc, all_losses)

        def aggregate_results(batch_loss, acc, all_losses):
            batch_loss = strategy.reduce('mean', batch_loss, axis=None)
            out_acc = {}
            out_all_losses = {}
            for key in acc.keys():
                out_acc[key] = strategy.reduce('mean', acc[key], axis=None)
            for key in all_losses.keys():
                out_all_losses[key] = strategy.reduce('mean', all_losses[key], axis=None)
            return (batch_loss, out_acc, out_all_losses)

        def step_fn(batch, difficulty, test=False):
            if test:
                if CFG['TPU']:
                    results = strategy.run(test_step, args=(batch, difficulty))
                    return aggregate_results(*results)
                else:
                    return test_step(batch, difficulty)
            elif CFG['TPU']:
                results = strategy.run(train_step, args=(batch, difficulty))
                return aggregate_results(*results)
            else:
                return train_step(batch, difficulty)
        if CFG['JUST_VISION']:
            (train_ds, _) = make_symbol_data(**CFG, test=False)
            (test_ds, _) = make_symbol_data(**CFG, test=True)
        else:
            (train_ds, _) = get_dataset(**CFG, test=False)
            (test_ds, _) = get_dataset(**CFG, test=True)
        replica_batch_size = CFG['batch_size']
        global_batch_size = (strategy.num_replicas_in_sync * replica_batch_size)
        tf_train_ds = tf.data.Dataset.from_tensor_slices(train_ds).batch(global_batch_size, drop_remainder=True)
        tf_test_ds = tf.data.Dataset.from_tensor_slices(test_ds).batch(global_batch_size, drop_remainder=True)
        path_prefix = CFG['root_filepath']
        model = get_model()
        run_dummy_batch(model)
        load_weights(model, path_prefix)
        optim = get_optim()
        spy_optim = get_spy_optim()
        perceptor = None
    difficulty = tf.convert_to_tensor(0)
    log_dir = f"logs/{CFG['run_name']}"
    os.makedirs(log_dir, exist_ok=True)
    train_log_dir = f'{path_prefix}{log_dir}/train'
    test_log_dir = f'{path_prefix}{log_dir}/test'
    train_summary_writer = tf.summary.create_file_writer(train_log_dir)
    test_summary_writer = tf.summary.create_file_writer(test_log_dir)
    current_time = str(datetime.datetime.now())
    CFG['current_time'] = current_time
    cfg_dir = os.path.join(log_dir, 'config.json')
    if CFG['USE_GS']:
        gs_upload_blob_from_string(json.dumps(CFG, indent=4), cfg_dir, print_str=True)
    else:
        with open(cfg_dir, 'w+') as f:
            f.write(json.dumps(CFG, indent=4))
    tr_num_samples = (train_ds.shape[0] if CFG['JUST_VISION'] else train_ds['adj'].shape[0])
    test_num_samples = (test_ds.shape[0] if CFG['JUST_VISION'] else test_ds['adj'].shape[0])
    tr_num_batches = (tr_num_samples // global_batch_size)
    test_num_batches = (test_num_samples // global_batch_size)
    best_epoch_loss = tf.float32.max
    for e_i in range(CFG['epochs']):
        tr_epoch_loss = 0
        test_epoch_loss = 0
        tr_epoch_acc = {}
        test_epoch_acc = {}
        all_losses = {}
        b_i = 0
        for train_batch in tf_train_ds:
            b_i += global_batch_size
            (batch_loss, batch_acc, batch_all_losses) = step_fn(train_batch, difficulty)
            tr_epoch_loss += batch_loss
            update_data_dict(tr_epoch_acc, batch_acc)
            update_data_dict(all_losses, batch_all_losses)
            print(f"(TRAIN) e [{e_i}/{CFG['epochs']}] b [{b_i}/{tr_num_samples}] loss {batch_loss}", end='\r')
        b_i = 0
        for test_batch in tf_test_ds:
            b_i += global_batch_size
            (batch_loss, batch_acc, _) = step_fn(test_batch, difficulty, test=True)
            test_epoch_loss += batch_loss
            update_data_dict(test_epoch_acc, batch_acc)
            print(f"(TEST) e [{e_i}/{CFG['epochs']}] b [{b_i}/{test_num_samples}] loss {batch_loss}", end='\r')
        tr_epoch_loss = (tr_epoch_loss / tr_num_batches)
        test_epoch_loss = (test_epoch_loss / test_num_batches)
        tr_epoch_acc = normalize_data_dict(tr_epoch_acc, tr_num_batches)
        test_epoch_acc = normalize_data_dict(test_epoch_acc, test_num_batches)
        all_losses = normalize_data_dict(all_losses, tr_num_batches)
        print(f'EPOCH {e_i} TRAIN LOSS: {tr_epoch_loss} TEST LOSS: {test_epoch_loss}')
        print(f'Train accuracies: {json.dumps(tr_epoch_acc, indent=4)}')
        print(f'Test accuracies: {json.dumps(test_epoch_acc, indent=4)}')
        print(f'All losses: {json.dumps(all_losses, indent=4)}')
        difficulty = update_difficulty(difficulty, tr_epoch_acc)
        print(f'DIFFICULTY FOR NEXT EPOCH: {difficulty}')
        if (not CFG['NOLOG']):
            with train_summary_writer.as_default():
                tf.summary.scalar('loss', tr_epoch_loss, step=e_i)
                for (name, metric) in tr_epoch_acc.items():
                    tf.summary.scalar(name, metric, step=e_i)
                for (name, specific_loss) in all_losses.items():
                    tf.summary.scalar(name, specific_loss, step=e_i)
            with test_summary_writer.as_default():
                tf.summary.scalar('loss', test_epoch_loss, step=e_i)
                for (name, metric) in test_epoch_acc.items():
                    tf.summary.scalar(name, metric, step=e_i)
        if (((e_i % CFG['save_checkpoint_every']) == 0) and (e_i != 0)):
            if (test_epoch_loss < best_epoch_loss):
                print(f'Saving checkpoint...')
                best_epoch_loss = test_epoch_loss
                save_weights(model, path_prefix)
        if (CFG['VISION'] and ((e_i % CFG['image_every']) == 0) and (e_i != 0)):
            (sample_imgs, aug_imgs, spy_imgs) = get_visual_samples(test_ds, model, test_num_samples, difficulty)
            sample_imgs = color_composite(sample_imgs)
            aug_imgs = color_composite(aug_imgs)
            if CFG['use_spy']:
                spy_imgs = color_composite(spy_imgs)
            (fig, axes) = (plt.subplots(3, 4) if CFG['use_spy'] else plt.subplots(2, 4))
            for img_i in range(4):
                axes[0][img_i].imshow(sample_imgs[img_i])
                axes[1][img_i].imshow(aug_imgs[img_i])
                if CFG['use_spy']:
                    axes[2][img_i].imshow(spy_imgs[img_i])
            if CFG['USE_GS']:
                gallery_dir = f"gallery/{CFG['run_name']}"
                img_name = os.path.join(gallery_dir, f'{e_i}.png')
                img_data = io.BytesIO()
                plt.savefig(img_data, format='png')
                img_data.seek(0)
                gs_upload_blob_from_memory(img_data, img_name)
            else:
                gallery_dir = f"{path_prefix}gallery/{CFG['run_name']}"
                os.makedirs(gallery_dir, exist_ok=True)
                img_name = os.path.join(gallery_dir, f'{e_i}.png')
                plt.savefig(img_name, format='png')
            plt.clf()
            plt.cla()
            plt.close()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    for  ...  in:
        if:
 = (plt.subplots if else)

idx = 33:------------------- similar code ------------------ index = 37, score = 6.0 
def show_latent_map(model, mdp):
    true_map = get_true_map(mdp)
    latent_map = draw_latent_map(model, mdp)
    latent_map = (np.array(latent_map) / 255.0)
    (f, axarr) = plt.subplots(1, 2, figsize=(15, 15))
    axarr[0].imshow(true_map)
    axarr[1].imshow(latent_map)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 34:------------------- similar code ------------------ index = 69, score = 6.0 
def run(device, show_plots, process_data=None, **get_data_kwargs):
    with NumpySeed(100):
        data = get_data(**get_data_kwargs)
        if (process_data is None):
            process_data = (lambda *x: x)
        (sprites, scales, offsets, backgrounds) = process_data(*data)
        with tf.device('/{}:0'.format(device)):
            images = render_sprites.render_sprites(sprites, scales, offsets, backgrounds)
            sess = get_session()
            result = sess.run(images)
        result = np.clip(result, 1e-06, (1 - 1e-06))
    if show_plots:
        import matplotlib.pyplot as plt
        (fig, (ax1, ax2)) = plt.subplots(1, 2)
        ax1.imshow(result[0])
        ax2.imshow(result[1])
        plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    if  ... :
 = plt.subplots

idx = 35:------------------- similar code ------------------ index = 62, score = 6.0 
def draw_lockdown_state_daily(stats_arg, show_plot, x_tick=10):
    (fig, ax) = plt.subplots(figsize=(15, 10))
    set_ax_lockdown_state_daily(ax, stats_arg['loc'], x_tick)
    if show_plot:
        plt.show()
    else:
        plt.savefig(('images/output/%d-lock-%d-%d.png' % (ts, stats_arg['hea'].shape[0], np.max(stats_arg['hea']))))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 36:------------------- similar code ------------------ index = 60, score = 6.0 
def plot_metric(C, diffs, routes_str=[], figsize=(10, 5), scatter_png='', hist_png='', scatter_alpha=0.3, scatter_size=2, scatter_cmap='jet', dpi=300):
    ' Plot output of cost metric in both scatterplot and histogram format'
    title = ('Path Length Similarity: ' + str(np.round(C, 2)))
    (fig, ax0) = plt.subplots(1, 1, figsize=((1 * figsize[0]), figsize[1]))
    ax0.scatter(list(range(len(diffs))), diffs, s=scatter_size, c=diffs, alpha=scatter_alpha, cmap=scatter_cmap)
    if (len(routes_str) > 0):
        xticklabel_pad = 0.1
        ax0.set_xticks(list(range(len(diffs))))
        ax0.set_xticklabels(routes_str, rotation=50, fontsize=4)
        ax0.tick_params(axis='x', which='major', pad=xticklabel_pad)
    ax0.set_ylabel('Length Diff (Normalized)')
    ax0.set_xlabel('Path ID')
    ax0.set_title(title)
    if scatter_png:
        plt.savefig(scatter_png, dpi=dpi)
    bins = np.linspace(0, 1, 30)
    bin_centers = np.mean(list(zip(bins, bins[1:])), axis=1)
    (hist, bin_edges) = np.histogram(diffs, bins=bins)
    (fig, ax1) = plt.subplots(nrows=1, ncols=1, figsize=figsize)
    ax1.bar(bin_centers, ((1.0 * hist) / len(diffs)), width=(bin_centers[1] - bin_centers[0]))
    ax1.set_xlim([0, 1])
    ax1.set_ylabel('Frac Num Routes')
    ax1.set_xlabel('Length Diff (Normalized)')
    ax1.set_title(('Length Diff Histogram - Score: ' + str(np.round(C, 2))))
    ax1.grid(True)
    if hist_png:
        plt.savefig(hist_png, dpi=dpi)
    return

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots
    return

idx = 37:------------------- similar code ------------------ index = 59, score = 6.0 
def plot_ori(self, c):
    from matplotlib import collections as mc
    import matplotlib.pyplot as plt
    line_len = 1
    lines = [[(p[0], p[1]), ((p[0] + (line_len * self._angles[p][0])), (p[1] + (line_len * self._angles[p][1])))] for p in self._nodes]
    lc = mc.LineCollection(lines, linewidth=2, color='green')
    (_, ax) = plt.subplots()
    ax.add_collection(lc)
    ax.autoscale()
    ax.margins(0.1)
    xs = [p[0] for p in self._nodes]
    ys = [p[1] for p in self._nodes]
    plt.scatter(xs, ys, color=c)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots()

idx = 38:------------------- similar code ------------------ index = 63, score = 6.0 
def plot_hex_grid(trajectory, shape=None, slice=(- 1), title='', colormap='Greys', vmin=None, vmax=None, edgecolor=None):
    activities = get_activities_over_time_as_list(trajectory)
    if (shape is not None):
        activities = np.array(activities).reshape((len(activities), shape[0], shape[1]))[slice]
    triples = _get_triples(activities)
    has_odd_rows = ((len(activities) % 2) != 0)
    (fig, ax) = plt.subplots(1)
    ax.set_aspect('equal')
    m = _get_scaled_colormap(triples, colormap, vmin, vmax)
    for t in triples:
        (x, y) = (_oddr_offset_to_pixel(t[0], t[1]) if has_odd_rows else _evenr_offset_to_pixel(t[0], t[1]))
        hex = RegularPolygon((x, y), numVertices=6, radius=1.0, orientation=np.radians(60), facecolor=m.to_rgba(t[2]), edgecolor=edgecolor)
        ax.add_patch(hex)
    ax.scatter([t[0] for t in triples], [t[1] for t in triples], marker='')
    plt.gca().invert_yaxis()
    plt.title(title)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 39:------------------- similar code ------------------ index = 44, score = 6.0 
def plot_orders(generation_idx_list, obs, size=5, plot_rows=4, out_path=None, **kwargs):
    'Plot multiple generation coordinate lists in a single figure. A star on the curve\n    denotes the pixel generated last. obs is a three-tuple of input image dimensions,\n    (input-channels-unused, num_rows, num_cols)'
    num = len(generation_idx_list)
    plot_cols = int(math.ceil((num / 4)))
    (fig, axes) = plt.subplots(plot_rows, plot_cols, figsize=((size * plot_cols), (size * plot_rows)))
    (pr, pc) = (0, 0)
    for generation_idx in generation_idx_list:
        ax = (axes[(pr, pc)] if (len(generation_idx_list) > 1) else axes)
        ax.hlines((np.arange((- 1), obs[1]) + 0.5), xmin=(- 0.5), xmax=(obs[2] - 0.5), alpha=0.5)
        ax.vlines((np.arange((- 1), obs[2]) + 0.5), ymin=(- 0.5), ymax=(obs[1] - 0.5), alpha=0.5)
        (rows, cols) = zip(*generation_idx)
        ax.plot(cols, rows, color='r')
        ax.scatter([cols[(- 1)]], [rows[(- 1)]], marker='*', s=100, c='k')
        ax.axis('equal')
        ax.invert_yaxis()
        pc = ((pc + 1) % plot_cols)
        if (pc == 0):
            pr += 1
    if out_path:
        plt.savefig(out_path, **kwargs)
    else:
        plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 40:------------------- similar code ------------------ index = 58, score = 6.0 
def draw_r0_evolution(stats_arg, show_plot, window_size=3, x_tick=10):
    (fig, ax) = plt.subplots(figsize=(15, 10))
    slid_new = np.array([np.convolve(sn, np.ones(window_size, dtype=int), 'valid') for sn in stats_arg['new']])
    slid_con = np.array([rolling_max(sc, window_size) for sc in (1 + stats_arg['con'])])
    set_ax_r0(ax, (slid_new / slid_con), '2 weeks sliding R0', x_tick=10)
    if show_plot:
        plt.show()
    else:
        plt.savefig(('images/output/%d-R0-evo-%d-%d.png' % (ts, stats_arg['hea'].shape[0], np.max(stats_arg['hea']))))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 41:------------------- similar code ------------------ index = 57, score = 6.0 
def run_training_loop(env, n_iter=200, max_episode_length=100, batch_size=512, learning_rate=0.01):
    'Trains a neural network policy using policy gradients.\n\n    Parameters\n    ----------\n    n_iter: number of training iterations\n    max_episode_length: episode length, up to 400\n    batch_size: number of steps used in each iteration\n    learning_rate: learning rate for the Adam optimizer\n\n    Returns\n    -------\n    A Policy instance, the trained policy.\n    '
    total_timesteps = 0
    agent = PolicyGradientAgent(env=env, learning_rate=learning_rate)
    avg_rewards = np.zeros(n_iter)
    avg_episode_lengths = np.zeros(n_iter)
    loss = np.zeros(n_iter)
    for itr in range(n_iter):
        if ((itr % 10) == 0):
            print(f'*****Iteration {itr}*****')
        (trajectories, timesteps_this_itr) = sample_trajectories_by_batch_size(env, agent.actor, batch_size, max_episode_length)
        total_timesteps += timesteps_this_itr
        avg_rewards[itr] = np.mean([get_trajectory_total_reward(tau) for tau in trajectories])
        avg_episode_lengths[itr] = np.mean([get_trajectory_len(tau) for tau in trajectories])
        loss[itr] = agent.train(trajectories).item()
        agent.actor.epsilon = np.maximum(0.05, (agent.actor.epsilon * 0.97))
    (fig, (ax1, ax2, ax3)) = plt.subplots(3, 1, sharex=True, figsize=[9, 9])
    ax1.plot(avg_rewards)
    ax1.set_xlabel('number of iterations')
    ax1.set_ylabel('average total reward')
    ax1.set_ylim(avg_rewards.min(), avg_rewards.max())
    ax2.plot(loss)
    ax2.set_xlabel('number of iterations')
    ax2.set_ylabel('training loss')
    ax2.set_ylim(loss.min(), loss.max())
    ax3.plot(avg_episode_lengths)
    ax3.set_xlabel('number of iterations')
    ax3.set_ylabel('average episode length')
    ax3.set_ylim(avg_episode_lengths.min(), avg_episode_lengths.max())
    plt.show()
    agent.actor.epsilon = 0.0
    return agent.actor

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 42:------------------- similar code ------------------ index = 68, score = 6.0 
def plot_dual_attention():
    'Plot dual attention vectors of 2 models over given context.'
    modelbw = build_model('imasm', (ARGS.model_dir + 'curr_imasm64_2.h5'), char_size=(len(CHAR_IDX) + 1), dim=ARGS.dim, iterations=ARGS.iterations, training=False)
    modelfw = build_model('fwimarsm', (ARGS.model_dir + 'curr_fwimarsm64.h5'), char_size=(len(CHAR_IDX) + 1), dim=ARGS.dim, iterations=ARGS.iterations, training=False)
    ctxs = ['p(X):-q(X).q(X):-r(X).r(X):-s(X).s(a).s(b).', 'p(X):-q(X);r(X).r(a).q(a).r(b).q(b).', 'p(X):-q(X).p(X):-r(X).p(b).r(a).q(b).']
    (fig, axes) = plt.subplots(1, 6)
    for (i, ctx) in enumerate(ctxs):
        for (j, m) in enumerate([modelbw, modelfw]):
            rs = ctx.split('.')[:(- 1)]
            dgen = LogicSeq([[([(r + '.') for r in rs], 'p(a).', 0)]], 1, False, False, pad=ARGS.pad)
            out = m.predict_generator(dgen)
            sims = out[:(- 1)]
            out = np.round(np.asscalar(out[(- 1)]), 2)
            sims = np.stack(sims, axis=0).squeeze()
            sims = sims.T
            ticks = ((['()'] if ARGS.pad else []) + ['$\\phi$'])
            axes[((i * 2) + j)].get_xaxis().set_ticks_position('top')
            sns.heatmap(sims, vmin=0, vmax=1, cmap='Blues', yticklabels=((rs + ticks) if ((j % 2) == 0) else False), xticklabels=range(1, 5), linewidths=0.5, square=True, cbar=False, ax=axes[((i * 2) + j)])
            axes[((i * 2) + j)].set_xlabel(('backward' if ((j % 2) == 0) else 'forward'))
    plt.tight_layout()
    showsave_plot()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 43:------------------- similar code ------------------ index = 55, score = 6.0 
def animate_activities(trajectory_or_activities, title='', shape=None, save=False, interval=50, colormap='Greys', vmin=None, vmax=None, show_grid=False, show_margin=True, scale=0.6, dpi=80, blit=True, with_timestep=False):
    if (len(trajectory_or_activities) is 0):
        raise Exception('there are no activities')
    if isinstance(trajectory_or_activities[0], State):
        activities = get_activities_over_time_as_list(trajectory_or_activities)
    else:
        activities = trajectory_or_activities
    if (shape is not None):
        activities = _reshape_for_animation(activities, shape)
    cmap = plt.get_cmap(colormap)
    (fig, ax) = plt.subplots()
    title_text = plt.title(title)
    if (not show_margin):
        fig.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=0, hspace=0)
    grid_linewidth = 0.0
    if show_grid:
        plt.xticks(np.arange((- 0.5), len(activities[0][0]), 1), '')
        plt.yticks(np.arange((- 0.5), len(activities[0]), 1), '')
        plt.tick_params(axis='both', which='both', length=0)
        grid_linewidth = 0.5
    vertical = np.arange((- 0.5), len(activities[0][0]), 1)
    horizontal = np.arange((- 0.5), len(activities[0]), 1)
    lines = ([[(x, y) for y in ((- 0.5), horizontal[(- 1)])] for x in vertical] + [[(x, y) for x in ((- 0.5), vertical[(- 1)])] for y in horizontal])
    grid = mcoll.LineCollection(lines, linestyles='-', linewidths=grid_linewidth, color='grey')
    ax.add_collection(grid)
    im = plt.imshow(activities[0], animated=True, cmap=cmap, vmin=vmin, vmax=vmax)
    if (not show_margin):
        (baseheight, basewidth) = im.get_size()
        fig.set_size_inches((basewidth * scale), (baseheight * scale), forward=True)
    i = {'index': 0}

    def updatefig(*args):
        i['index'] += 1
        if (i['index'] == len(activities)):
            i['index'] = 0
        im.set_array(activities[i['index']])
        if with_timestep:
            title_text.set_text(('timestep: %s' % (i['index'] + 1)))
        return (im, grid, title_text)
    ani = animation.FuncAnimation(fig, updatefig, interval=interval, blit=blit, save_count=len(activities))
    if save:
        ani.save('evolved.gif', dpi=dpi, writer='imagemagick')
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots()

idx = 44:------------------- similar code ------------------ index = 54, score = 6.0 
def animate_hex(trajectory, title='', shape=None, save=False, interval=50, colormap='Greys', vmin=None, vmax=None, edgecolor=None):
    activities = get_activities_over_time_as_list(trajectory)
    if (shape is not None):
        activities = np.reshape(activities, (len(activities), shape[0], shape[1]))
    triples = _get_triples(activities[0])
    has_odd_rows = ((len(activities[0]) % 2) != 0)
    (fig, ax) = plt.subplots(1)
    ax.set_aspect('equal')
    m = _get_scaled_colormap(triples, colormap, vmin, vmax)
    patches = []
    for t in triples:
        (x, y) = (_oddr_offset_to_pixel(t[0], t[1]) if has_odd_rows else _evenr_offset_to_pixel(t[0], t[1]))
        hex = RegularPolygon((x, y), numVertices=6, radius=1.0, orientation=np.radians(60), edgecolor=edgecolor)
        patches.append(hex)
    p = PatchCollection(patches, match_original=True, cmap=m.get_cmap())
    ax.add_collection(p)
    i = {'index': 0}

    def update(*args):
        i['index'] += 1
        if (i['index'] == len(activities)):
            i['index'] = 0
        new_triples = _get_triples(activities[i['index']])
        p.set_array(np.array([tr[2] for tr in new_triples]))
        return (p,)
    ax.scatter([t[0] for t in triples], [t[1] for t in triples], marker='')
    plt.gca().invert_yaxis()
    plt.title(title)
    ani = animation.FuncAnimation(fig, update, interval=interval, blit=True, save_count=len(activities))
    if save:
        ani.save('evolved.gif', dpi=80, writer='imagemagick')
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 45:------------------- similar code ------------------ index = 64, score = 6.0 
@contextmanager
def canvas(image_file=None, **kwargs):
    'Generic matplotlib context.'
    (fig, ax) = plt.subplots(**kwargs)
    (yield ax)
    fig.set_tight_layout(True)
    if image_file:
        fig.savefig(image_file, dpi=300)
    fig.show()
    plt.close(fig)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 46:------------------- similar code ------------------ index = 71, score = 6.0 
def plot_attention():
    'Plot attention vector over given context.'
    model = create_model(iterations=ARGS.iterations, training=False)
    ctxs = ['p(X):-q(X).q(X):-r(X).r(X):-s(X).s(a).s(c).', 'p(X):-q(X);r(X).r(a).q(a).r(b).q(c).', 'p(X):-q(X).p(X):-r(X).p(c).r(a).q(c).']
    (fig, axes) = plt.subplots(1, 6)
    for (i, ctx) in enumerate(ctxs):
        for (j, t) in enumerate(['p(a).', 'p(b).']):
            rs = ctx.split('.')[:(- 1)]
            dgen = LogicSeq([[([(r + '.') for r in rs], t, 0)]], 1, False, False, pad=ARGS.pad)
            out = model.predict_generator(dgen)
            sims = out[:(- 1)]
            out = np.round(np.asscalar(out[(- 1)]), 2)
            sims = np.stack(sims, axis=0).squeeze()
            sims = sims.T
            ticks = ((['()'] if ARGS.pad else []) + ['$\\phi$'])
            axes[((i * 2) + j)].get_xaxis().set_ticks_position('top')
            sns.heatmap(sims, vmin=0, vmax=1, cmap='Blues', yticklabels=((rs + ticks) if ((j % 2) == 0) else False), xticklabels=range(1, (ARGS.iterations + 1)), linewidths=0.5, square=True, cbar=False, ax=axes[((i * 2) + j)])
            axes[((i * 2) + j)].set_xlabel((('p(a) ' + str(out)) if ((j % 2) == 0) else ('p(b) ' + str(out))))
    plt.tight_layout()
    showsave_plot()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 47:------------------- similar code ------------------ index = 70, score = 6.0 
def draw_specific_population_state_daily(stats_arg, show_plot, x_tick=10, style='P'):
    (fig, ax) = plt.subplots(figsize=(15, 10))
    set_ax_specific_population_state_daily(ax, stats_arg, x_tick, style)
    if show_plot:
        plt.show()
    else:
        plt.savefig(('images/output/%d-style-%s-%d-%d.png' % (ts, style, stats_arg['hea'].shape[0], np.max(stats_arg['hea']))))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 48:------------------- similar code ------------------ index = 53, score = 6.0 
def _get_road_buffer(geoJson, im_vis_file, output_raster, buffer_meters=2, burnValue=1, buffer_cap_style=6, useSpacenetLabels=False, plot_file='', figsize=(11, 3), fontsize=6, dpi=800, show_plot=False, valid_road_types=set([]), verbose=False):
    "\n    Wrapper around create_buffer_geopandas(), with plots\n    Get buffer around roads defined by geojson and image files\n    valid_road_types serves as a filter of valid types (no filter if len==0)\n    https://wiki.openstreetmap.org/wiki/Key:highway\n    valid_road_types = set(['motorway', 'trunk', 'primary', 'secondary',\n                            'tertiary',\n                            'motorway_link', 'trunk_link', 'primary_link',\n                            'secondary_link', 'tertiary_link',\n                            'unclassified', 'residential', 'service' ])\n    "
    try:
        inGDF_raw = gpd.read_file(geoJson)
    except:
        mask_gray = np.zeros(cv2.imread(im_vis_file, 0).shape)
        cv2.imwrite(output_raster, mask_gray)
        return ([], [])
    if useSpacenetLabels:
        inGDF = inGDF_raw
        try:
            inGDF['type'] = inGDF['road_type'].values
            inGDF['class'] = 'highway'
            inGDF['highway'] = 'highway'
        except:
            pass
    elif ((len(valid_road_types) > 0) and (len(inGDF_raw) > 0)):
        if ('highway' in inGDF_raw.columns):
            inGDF = inGDF_raw[inGDF_raw['highway'].isin(valid_road_types)]
            inGDF['type'] = inGDF['highway'].values
            inGDF['class'] = 'highway'
        else:
            inGDF = inGDF_raw[inGDF_raw['type'].isin(valid_road_types)]
            inGDF['highway'] = inGDF['type'].values
        if verbose:
            print('gdf.type:', inGDF['type'])
            if (len(inGDF) != len(inGDF_raw)):
                print('len(inGDF), len(inGDF_raw)', len(inGDF), len(inGDF_raw))
                print("gdf['type']:", inGDF['type'])
    else:
        inGDF = inGDF_raw
        try:
            inGDF['type'] = inGDF['highway'].values
            inGDF['class'] = 'highway'
        except:
            pass
    gdf_buffer = create_buffer_geopandas(inGDF, buffer_distance_meters=buffer_meters, buffer_cap_style=buffer_cap_style, dissolve_by='class', projectToUTM=True)
    if (len(gdf_buffer) == 0):
        mask_gray = np.zeros(cv2.imread(im_vis_file, 0).shape)
        cv2.imwrite(output_raster, mask_gray)
    else:
        gdf_to_array(gdf_buffer, im_vis_file, output_raster, burnValue=burnValue)
    mask_gray = cv2.imread(output_raster, 0)
    if plot_file:
        (fig, (ax0, ax1, ax2, ax3)) = plt.subplots(1, 4, figsize=figsize)
        try:
            gdfRoadLines = gpd.read_file(geoJson)
            gdfRoadLines.plot(ax=ax0, marker='o', color='red')
        except:
            ax0.imshow(mask_gray)
        ax0.axis('off')
        ax0.set_aspect('equal')
        ax0.set_title('Unfiltered Roads from GeoJson', fontsize=fontsize)
        im_vis = cv2.imread(im_vis_file, 1)
        img_mpl = cv2.cvtColor(im_vis, cv2.COLOR_BGR2RGB)
        ax1.imshow(img_mpl)
        ax1.axis('off')
        ax1.set_title('Raw Image', fontsize=fontsize)
        ax2.imshow(mask_gray)
        ax2.axis('off')
        ax2.set_title((('Roads Mask (' + str(np.round(buffer_meters))) + ' meter buffer)'), fontsize=fontsize)
        ax3.imshow(img_mpl)
        z = mask_gray.astype(float)
        z[(z == 0)] = np.nan
        palette = plt.cm.gray
        palette.set_over('orange', 1.0)
        ax3.imshow(z, cmap=palette, alpha=0.4, norm=matplotlib.colors.Normalize(vmin=0.5, vmax=0.9, clip=False))
        ax3.set_title('Raw Image + Buffered Roads', fontsize=fontsize)
        ax3.axis('off')
        plt.savefig(plot_file, dpi=dpi)
        if (not show_plot):
            plt.close()
    return (mask_gray, gdf_buffer)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    if  ... :
 = plt.subplots

idx = 49:------------------- similar code ------------------ index = 67, score = 6.0 
def plot_transfer(extension):
    yolo_path = os.path.join(data_dir, 'transfer/run_search_yolo-air-transfer_env=size=14-in-colour=False-task=scatter_alg=yolo-air-transfer_duration=long_seed=0_2018_07_19_14_21_39/')
    baseline_path_ap = os.path.join(data_dir, 'transfer/run_search_transfer-baseline_env=size=14-in-colour=False-task=scatter_alg=baseline_duration=oak_seed=0_2018_07_20_11_27_19/')
    baseline_path_count_1norm = os.path.join(data_dir, 'transfer/run_search_transfer-baseline-sc=count-1norm_env=size=14-in-colour=False-task=scatter_alg=baseline_duration=oak_seed=0_2018_07_26_12_15_50/')
    baseline_path_count_error = os.path.join(data_dir, 'transfer/run_search_transfer-baseline-sc=count-error_env=size=14-in-colour=False-task=scatter_alg=baseline_duration=oak_seed=0_2018_07_26_12_29_21/')
    (fig, axes) = plt.subplots(1, 3, figsize=(8, 2.2))
    ax = axes[0]
    y_func = (lambda y: (100 * y))
    measure = '_test_AP'
    yolo_data = get_transfer_data(yolo_path, 'n_train', measure, 'ci95', y_func=y_func)
    for ((x, y, *yerr), key) in yolo_data:
        label = 'Trained on {}--{} digits'.format(key.min_chars, key.max_chars)
        ax.errorbar(x, y, yerr=yerr, label=label)
    (x, y) = get_transfer_baseline_data(baseline_path_ap, 'n_train', measure, 'ci95', y_func=y_func)
    ax.plot(x, y, label='ConnComp')
    fontsize = None
    labelsize = None
    ax.set_ylabel('Average Precision', fontsize=fontsize)
    ax.tick_params(axis='both', labelsize=labelsize)
    ax.set_ylim((0.0, 105.0))
    ax.set_xlabel('\\# Digits in Test Image', fontsize=fontsize)
    ax.set_xticks([0, 5, 10, 15, 20])
    ax.legend(loc='lower left', fontsize=8)
    ax = axes[1]
    measure = '_test_count_1norm'
    yolo_data = get_transfer_data(yolo_path, 'n_train', measure, 'ci95')
    for ((x, y, *yerr), key) in yolo_data:
        label = 'Trained on {}--{} digits'.format(key.min_chars, key.max_chars)
        ax.errorbar(x, y, yerr=yerr, label=label)
    (x, y) = get_transfer_baseline_data(baseline_path_count_1norm, 'n_train', measure, 'ci95')
    ax.plot(x, y, label='ConnComp')
    ax.set_ylabel('Count Absolute Error', fontsize=fontsize)
    ax.set_xlabel('\\# Digits in Test Image', fontsize=fontsize)
    ax.tick_params(axis='both', labelsize=labelsize)
    ax.set_ylim((0.0, 3.1))
    ax.set_xticks([0, 5, 10, 15, 20])
    ax = axes[2]
    measure = '_test_count_error'
    yolo_data = get_transfer_data(yolo_path, 'n_train', measure, 'ci95')
    for ((x, y, *yerr), key) in yolo_data:
        label = 'Trained on {}--{} digits'.format(key.min_chars, key.max_chars)
        ax.errorbar(x, y, yerr=yerr, label=label)
    (x, y) = get_transfer_baseline_data(baseline_path_count_error, 'n_train', measure, 'ci95')
    ax.plot(x, y, label='ConnComp')
    ax.set_ylabel('Count 0-1 Error', fontsize=fontsize)
    ax.tick_params(axis='both', labelsize=labelsize)
    ax.set_ylim((0.0, 1.05))
    ax.set_xlabel('\\# Digits in Test Image', fontsize=fontsize)
    ax.set_xticks([0, 5, 10, 15, 20])
    plt.subplots_adjust(left=0.07, bottom=0.2, right=0.98, top=0.94, wspace=0.27)
    plot_path = os.path.join(plot_dir, ('transfer/main.' + extension))
    os.makedirs(os.path.dirname(plot_path), exist_ok=True)
    fig.savefig(plot_path)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
 = plt.subplots

idx = 50:------------------- similar code ------------------ index = 52, score = 6.0 
def plot1D(x, y, color=None, label=None, xlabel=None, ylabel=None, xlim=None, ylim=None, twinx=False, legend=None, tight_layout=None, title=None):
    '\n    Creates a 1D plot of the given x and y values.\n\n    :param x: A list representing the values of the x-axis.\n\n    :param y: A list representing the values of the y-axis. If the values of this list are also lists, then each will\n              be plotted as a separate series on the y-axis.\n\n    :param color: A string, representing the color of the series, or a list of colors, representing the color of each\n                   series to be plotted. The number of colors must match the number of series. The color values must\n                   be recognizable by Matplotlib.\n\n    :param label: A string or number, or a list of strings or numbers, representing the labels of each series to be\n                  plotted. The number of labels must match the number of series.\n\n    :param xlabel: A string representing the label of the x-axis.\n\n    :param ylabel: A string, or list of at most two strings, representing the label(s) of the y-axis.\n\n    :param xlim: A 2-tuple of numbers, representing the limits of the x-axis.\n\n    :param ylim: A 2-tuple of numbers, or a list of at most two 2-tuples of numbers, representing the\n                 limits of the y-axis.\n\n    :param twinx: If True, the provided y series will be plotted on two separate y-axes, and there must\n                  be at least two series of y values provided. If there are more than two series of y values,\n                  then each series will be plotted on alternating y-axes. (Default is False)\n\n    :param legend: A dict, or a list of at most two dicts, representing the arguments to the legend\n                   function of Matplotlib.\n\n    :param tight_layout: A dict representing the arguments to the tight_layout function of Matplotlib.\n\n    :param title: The plot title.\n    '
    axes = []
    (fig, ax1) = plt.subplots()
    axes.append(ax1)
    if twinx:
        axes.append(ax1.twinx())
        if (len(y) < 2):
            raise Exception('there must be at least two series of y values provided')
        for _y in y:
            if (not isinstance(_y, (list, np.ndarray))):
                raise Exception('an item in y must be a list representing a y series')
    current_axis_idx = 0
    is_multiseries = isinstance(y[0], (list, np.ndarray))

    def _get_item(items, i):
        if isinstance(items, str):
            return items
        if isinstance(items, collections.Sequence):
            return items[i]
        return items
    if (not is_multiseries):
        y = [y]
    for (i, y_series) in enumerate(y):
        current_axis = axes[(current_axis_idx % len(axes))]
        plot_args = {}
        if label:
            plot_args['label'] = _get_item(label, i)
        if color:
            plot_args['color'] = _get_item(color, i)
        current_axis.plot(x, y_series, **plot_args)
        if xlabel:
            current_axis.set_xlabel(xlabel)
        if ylabel:
            ylabel_args = {}
            if color:
                ylabel_args['color'] = _get_item(color, i)
            current_axis.set_ylabel(_get_item(ylabel, (i % 2)), **ylabel_args)
        if xlim:
            current_axis.set_xlim(xlim)
        if ylim:
            current_axis.set_ylim(_get_item(ylim, (i % 2)))
        if legend:
            current_axis.legend(**legend)
        current_axis_idx += 1
    if tight_layout:
        plt.tight_layout(**tight_layout)
    if title:
        plt.title(title)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots()

idx = 51:------------------- similar code ------------------ index = 51, score = 6.0 
def plot(ts, interpolate='previous', figure_width=12, linewidth=1, marker='o', markersize=3, color='#222222', aspect_ratio=None, font=None):
    try:
        import matplotlib.pyplot as plt
        from matplotlib import font_manager
    except ImportError:
        msg = 'need to install matplotlib for `plot` function'
        raise ImportError(msg)
    if (font is None):
        available_fonts = set((f.name for f in font_manager.fontManager.ttflist))
        for font in FONTS:
            if (font in available_fonts):
                break
    if (aspect_ratio is None):
        try:
            n_unique_values = len(ts.distribution())
        except KeyError:
            n_unique_values = 0
        scaled = min(MAX_ASPECT_POINTS, (max(2, n_unique_values) - 2))
        aspect_ratio = (MIN_ASPECT_RATIO + ((MAX_ASPECT_RATIO - MIN_ASPECT_RATIO) * (scaled / MAX_ASPECT_POINTS)))
    try:
        drawstyle = INTERPOLATE_DRAWSTYLE[interpolate]
    except KeyError:
        raise ValueError("invalid value for interpolate='{}', must be in {}".format(interpolate, set(INTERPOLATE_DRAWSTYLE.keys())))
    with plt.style.context(PLOT_STYLE):
        (figure, axes) = plt.subplots(figsize=(figure_width, (aspect_ratio * figure_width)))
        items = ts.items()
        if items:
            (x, y) = zip(*items)
        else:
            (x, y) = ([], [])
        plot = axes.plot(x, y, linewidth=linewidth, drawstyle=drawstyle, marker=marker, markersize=markersize, color=color)
        axes.set_aspect((aspect_ratio / axes.get_data_ratio()))
        axes.xaxis.set_major_locator(plt.MaxNLocator(int((figure_width / 2))))
        if font:
            plt.xticks(fontname=font)
            plt.yticks(fontname=font)
    return (figure, axes)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    with:
 = plt.subplots

idx = 52:------------------- similar code ------------------ index = 50, score = 6.0 
def save_traj(images, image_goal, gif_path, task):
    (fig, aa) = plt.subplots(1, 2)
    m1 = aa[0].matshow(images[0], cmap=plt.cm.gray, vmin=0.0, vmax=1.0)
    aa[0].set_title('Time step 0')
    aa[0].set_yticklabels([])
    aa[0].set_xticklabels([])
    m2 = aa[1].matshow(image_goal, cmap=plt.cm.gray, vmin=0.0, vmax=1.0)
    aa[1].set_title('goal')
    aa[1].set_yticklabels([])
    aa[1].set_xticklabels([])
    fig.tight_layout()

    def updatemat2(t):
        m1.set_data(images[t])
        aa[0].set_title(('Time step ' + str(t)))
        m2.set_data(image_goal)
        return (m1, m2)
    frames = len(images)
    if (task in ['plane', 'cartpole']):
        fps = 2
    else:
        fps = 20
    anim = FuncAnimation(fig, updatemat2, frames=frames, interval=200, blit=True, repeat=True)
    Writer = writers['imagemagick']
    writer = Writer(fps=fps, metadata=dict(artist='Me'), bitrate=1800)
    anim.save(gif_path, writer=writer)
    plt.clf()
    plt.cla()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 53:------------------- similar code ------------------ index = 49, score = 6.0 
def _plot_reconstruction(self, updater, fetched):
    inp = fetched['inp']
    output = fetched['output']
    prediction = fetched.get('prediction', None)
    targets = fetched.get('targets', None)
    (_, image_height, image_width, _) = inp.shape
    obj = fetched['obj'].reshape(self.N, (- 1))
    anchor_box = updater.network.anchor_box
    (yt, xt, ys, xs) = np.split(fetched['normalized_box'], 4, axis=(- 1))
    (yt, xt, ys, xs) = coords_to_pixel_space(yt, xt, ys, xs, (image_height, image_width), anchor_box, top_left=True)
    box = np.concatenate([yt, xt, ys, xs], axis=(- 1))
    box = box.reshape(self.N, (- 1), 4)
    n_annotations = fetched.get('n_annotations', ([0] * self.N))
    annotations = fetched.get('annotations', None)
    actions = fetched.get('actions', None)
    sqrt_N = int(np.ceil(np.sqrt(self.N)))
    on_colour = np.array(to_rgb('xkcd:azure'))
    off_colour = np.array(to_rgb('xkcd:red'))
    cutoff = 0.5
    (fig, axes) = plt.subplots((2 * sqrt_N), (2 * sqrt_N), figsize=(20, 20))
    axes = np.array(axes).reshape((2 * sqrt_N), (2 * sqrt_N))
    for (n, (pred, gt)) in enumerate(zip(output, inp)):
        i = int((n / sqrt_N))
        j = int((n % sqrt_N))
        ax1 = axes[((2 * i), (2 * j))]
        self.imshow(ax1, gt)
        title = ''
        if (prediction is not None):
            title += 'target={}, prediction={}'.format(np.argmax(targets[n]), np.argmax(prediction[n]))
        if (actions is not None):
            title += ', actions={}'.format(actions[(n, 0)])
        ax1.set_title(title)
        ax2 = axes[((2 * i), ((2 * j) + 1))]
        self.imshow(ax2, pred)
        ax3 = axes[(((2 * i) + 1), (2 * j))]
        self.imshow(ax3, pred)
        ax4 = axes[(((2 * i) + 1), ((2 * j) + 1))]
        self.imshow(ax4, pred)
        for (o, (top, left, height, width)) in zip(obj[n], box[n]):
            colour = ((o * on_colour) + ((1 - o) * off_colour))
            rect = patches.Rectangle((left, top), width, height, linewidth=2, edgecolor=colour, facecolor='none')
            ax4.add_patch(rect)
            if (o > cutoff):
                rect = patches.Rectangle((left, top), width, height, linewidth=2, edgecolor=colour, facecolor='none')
                ax3.add_patch(rect)
        for k in range(n_annotations[n]):
            (valid, _, _, top, bottom, left, right) = annotations[n][k]
            if (not valid):
                continue
            height = (bottom - top)
            width = (right - left)
            rect = patches.Rectangle((left, top), width, height, linewidth=1, edgecolor='xkcd:yellow', facecolor='none')
            ax1.add_patch(rect)
            rect = patches.Rectangle((left, top), width, height, linewidth=1, edgecolor='xkcd:yellow', facecolor='none')
            ax3.add_patch(rect)
            rect = patches.Rectangle((left, top), width, height, linewidth=1, edgecolor='xkcd:yellow', facecolor='none')
            ax4.add_patch(rect)
        for ax in axes.flatten():
            ax.set_axis_off()
    if (prediction is None):
        plt.subplots_adjust(left=0, right=1, top=1, bottom=0, wspace=0.1, hspace=0.1)
    else:
        plt.subplots_adjust(left=0, right=1, top=0.9, bottom=0, wspace=0.1, hspace=0.2)
    self.savefig('sampled_reconstruction', fig, updater)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 54:------------------- similar code ------------------ index = 48, score = 6.0 
def plot_matches(image1, image2, keypoints1, keypoints2, matches12, **kwargs):
    (fig, ax) = plt.subplots()
    plot_matches_(ax, image1, image2, xy_to_yx(keypoints1), xy_to_yx(keypoints2), matches12, **kwargs)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots()

idx = 55:------------------- similar code ------------------ index = 47, score = 6.0 
def draw_population_state_daily(stats_arg, show_plot, x_tick=10):
    (fig, ax) = plt.subplots(figsize=(15, 10))
    set_ax_mean_population_state_daily(ax, stats_arg, x_tick)
    if show_plot:
        plt.show()
    else:
        plt.savefig(('images/output/%d-pop-%d-%d.png' % (ts, stats_arg['hea'].shape[0], np.max(stats_arg['hea']))))

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 56:------------------- similar code ------------------ index = 46, score = 6.0 
def figure_plot(steer_pred1, steer_pred2, steer_gt, iteration):
    (fig, ax) = plt.subplots(figsize=(16, 7))
    time_vec = range(0, len(steer_pred1))
    time_vec = [((float(x) / 10.0) + 200) for x in time_vec]
    ax.plot(time_vec, steer_pred1, 'g', label='Model 2')
    ax.plot(time_vec, steer_pred2, 'r', label='Model 1')
    ax.plot(time_vec, steer_gt, 'b', label='Ground Truth')
    ax.set_ylim([(- 0.6), 0.8])
    ax.set_xlim([200, 650])
    for item in (([ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels()) + ax.get_yticklabels()):
        item.set_fontsize(24)
    ax.legend(loc='upper center', ncol=3)
    ax.set_xlabel('Time (seconds)')
    ax.set_ylabel('Steering Value (radians)')
    fig.savefig((('footage_offline/plot' + str(iteration)) + '.png'), orientation='landscape', bbox_inches='tight')
    plt.close(fig)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 57:------------------- similar code ------------------ index = 45, score = 6.0 
def plot(all_metrics, plot_param, out_file=None):
    data = {'x': [], 'y': [], 'size': [], 'color': []}
    for (experiment, metrics) in all_metrics.items():
        for key in data:
            data[key] += metrics[plot_param[key]['data']]
    for key in data:
        data[key] = np.array(data[key])
    nans = np.logical_or.reduce((np.isnan(data['x']), np.isnan(data['y']), np.isinf(data['x']), np.isinf(data['y'])))
    print(('\n ** Removing %d NaNs and infs before log **' % np.sum(nans)))
    for key in data:
        data[key] = data[key][np.invert(nans)]
    if (('plot_best_n_percent' in plot_param) and plot_param['plot_best_n_percent']):
        sorting_indices = np.argsort(data['x'])
        selected_indices = sorting_indices[:int(((plot_param['plot_best_n_percent'] / 100.0) * len(sorting_indices)))]
        for key in data:
            data[key] = data[key][selected_indices]
    data_x = ((np.log(data['x']) / np.log(10)) if plot_param['x']['log'] else np.copy(data['x']))
    data_y = ((np.log(data['y']) / np.log(10)) if plot_param['y']['log'] else np.copy(data['y']))
    nans = np.logical_or.reduce((np.isnan(data_x), np.isnan(data_y), np.isinf(data_x), np.isinf(data_y)))
    print(('\n ** Removing %d NaNs and infs after log **' % np.sum(nans)))
    for key in data:
        data[key] = data[key][np.invert(nans)]
    data_x = data_x[np.invert(nans)]
    data_y = data_y[np.invert(nans)]
    (fig, ax) = plt.subplots(figsize=(8, 8))
    SMALL_SIZE = 8
    MEDIUM_SIZE = 10
    BIGGER_SIZE = 12
    plt.set_cmap('jet')
    plt.rc('font', size=16)
    plt.rc('axes', labelsize=20)
    (x_lim, y_lim) = compute_lims(data_x, data_y)
    ax.set_xlim(x_lim)
    ax.set_ylim(y_lim)
    plt.locator_params(axis='x', nbins=4)
    plt.locator_params(axis='y', nbins=8)
    x_label = plot_param['x']['data']
    y_label = plot_param['y']['data']
    if plot_param['x']['log']:
        x_label += ' (log)'
        ax.set_xticklabels([('%.3f' % np.power(10, float(t))) for t in ax.get_xticks()])
    if plot_param['y']['log']:
        y_label += ' (log)'
        ax.set_yticklabels([('%.2f' % np.power(10, float(t))) for t in ax.get_yticks()])
    else:
        ax.set_yticklabels([('%.2f' % float(t)) for t in ax.get_yticks()])
    ax.set_xlabel(x_label)
    ax.set_ylabel(y_label)
    ax.scatter(data_x, data_y, s=data['size'], c=data['color'], alpha=0.5)
    corr = np.corrcoef(data_x, data_y)[(0, 1)]
    print(('Correlation %f' % corr))
    if ('title' in plot_param):
        title = plot_param['title']
    else:
        title = ((plot_param['y']['data'] + ' vs ') + plot_param['x']['data'])
    plt.title(('Correlation %.2f' % corr))
    if plot_param['print']:
        fig.savefig(out_file, bbox_inches='tight')

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 58:------------------- similar code ------------------ index = 61, score = 6.0 
def view3d_image(input_im, cmap='gray', title='', spacing=None, slice_axis=0):
    if (spacing is None):
        spacing = [1, 1, 1]
    if isinstance(input_im, sitk.Image):
        input_numpy = sitk.GetArrayFromImage(input_im)
        spacing = input_im.GetSpacing()[::(- 1)]
    else:
        input_numpy = input_im
    if (slice_axis == 0):
        aspect = (spacing[1] / spacing[2])
    elif (slice_axis == 1):
        input_numpy = np.transpose(input_numpy, [1, 0, 2])
        aspect = (spacing[0] / spacing[2])
    elif (slice_axis == 2):
        input_numpy = np.transpose(input_numpy, [2, 0, 1])
        aspect = (spacing[0] / spacing[1])
    else:
        raise ValueError((('slice_axis = ' + str(slice_axis)) + ', but it should be in range of [0, 1, 2]'))
    (fig, ax) = plt.subplots(1, 1)
    tracker = IndexTracker(ax, input_numpy, cmap=cmap, title=title, aspect=aspect)
    fig.canvas.mpl_connect('scroll_event', tracker.onscroll)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 59:------------------- similar code ------------------ index = 13, score = 5.0 
def plot_degree_mrr(node_ranks):
    degree_rank = {}
    for (node, rank) in node_ranks.items():
        node_degree = node.get_degree()
        if (node_degree not in degree_rank):
            degree_rank[node_degree] = []
        degree_rank[node_degree].append((sum(rank) / len(rank)))
    degrees = []
    ranks = []
    for k in sorted(degree_rank.keys()):
        if (k < 20):
            for rank in degree_rank[k]:
                if (rank < 100):
                    degrees.append(k)
                    ranks.append(rank)
    (fig, ax) = plt.subplots()
    ax.scatter(degrees, ranks, marker='.')
    ax.set(xlabel='degree', ylabel='mean ranks')
    ax.grid()
    fig.savefig('comet_cn_degree_ranks.png')

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
 = plt.subplots()

idx = 60:------------------- similar code ------------------ index = 42, score = 5.0 
def getAxis(axis):
    if (axis is not False):
        ax = axis
        fig = ax.figure.canvas
    else:
        (fig, ax) = plt.subplots()
    return (fig, ax)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
    if:    else:
 = plt.subplots()

idx = 61:------------------- similar code ------------------ index = 19, score = 5.0 
def getAxis(axis):
    if (axis is not False):
        ax = axis
        fig = ax.figure.canvas
    else:
        (fig, ax) = plt.subplots()
    return (fig, ax)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
    if:    else:
 = plt.subplots()

idx = 62:------------------- similar code ------------------ index = 20, score = 5.0 
def plot_dielectric_functions(dielectric, ax=None):
    real_dielectric = parse_dielectric_data(dielectric[1])
    imag_dielectric = parse_dielectric_data(dielectric[2])
    if (ax is None):
        (fig, ax) = plt.subplots(1, 1, figsize=(6.0, 3.0))
    else:
        fig = None
    ax.plot(dielectric[0], np.mean(real_dielectric, axis=1), '-', zorder=2)
    ax.plot(dielectric[0], np.mean(imag_dielectric, axis=1), '-', zorder=2)
    ax.set_xlim([0, 8])
    ax.set_ylim([0, 5])
    return fig

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    if:
 = plt.subplots

idx = 63:------------------- similar code ------------------ index = 27, score = 5.0 
def plot_matches(image0, image1, keypoints0, keypoints1, matches01):
    (fig, ax) = plt.subplots()
    skimage_plot_matches(ax, image0, image1, xy_to_yx(keypoints0), xy_to_yx(keypoints1), matches01)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots()

idx = 64:------------------- similar code ------------------ index = 28, score = 5.0 
def __init__(self, traj_params, drone_names, drone_i, drone_params, use_vel_constraints=False, plot_gtp=False):
    super().__init__(drone_name=drone_names[drone_i], viz_traj=True)
    self.drone_names = drone_names
    self.drone_i = drone_i
    self.drone_params = drone_params
    self.traj_params = traj_params
    self.use_vel_constraints = use_vel_constraints
    self.plot_gtp = plot_gtp
    self.controller = None
    if self.plot_gtp:
        (self.fig, self.ax) = plt.subplots()
        self.line_state = None
        self.lines = ([None] * 2)
        self.fig2 = plt.figure(2)
        self.ax3d = self.fig2.add_subplot(111, projection='3d')
    print('baseline_racer_gtp ready!')
    if self.traj_params.blocking:
        print('   with blocking behavior activated')

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    if:
 = plt.subplots()

idx = 65:------------------- similar code ------------------ index = 72, score = 5.0 
def plot_graph(G, bbox=None, fig_height=6, fig_width=None, margin=0.02, axis_off=True, equal_aspect=False, bgcolor='w', show=True, save=False, close=True, file_format='png', filename='', dpi=300, annotate=False, node_color='#66ccff', node_size=15, node_alpha=1, node_edgecolor='none', node_zorder=1, edge_color='#999999', edge_linewidth=1, edge_alpha=1, use_geom=True):
    "\n    Plot a networkx spatial graph.\n    Parameters\n    ----------\n    G : networkx multidigraph\n    bbox : tuple\n        bounding box as north,south,east,west - if None will calculate from\n        spatial extents of data. if passing a bbox, you probably also want to\n        pass margin=0 to constrain it.\n    fig_height : int\n        matplotlib figure height in inches\n    fig_width : int\n        matplotlib figure width in inches\n    margin : float\n        relative margin around the figure\n    axis_off : bool\n        if True turn off the matplotlib axis\n    equal_aspect : bool\n        if True set the axis aspect ratio equal\n    bgcolor : string\n        the background color of the figure and axis\n    show : bool\n        if True, show the figure\n    save : bool\n        if True, save the figure as an image file to disk\n    close : bool\n        close the figure (only if show equals False) to prevent display\n    file_format : string\n        the format of the file to save (e.g., 'jpg', 'png', 'svg')\n    filename : string\n        the name of the file if saving\n    dpi : int\n        the resolution of the image file if saving\n    annotate : bool\n        if True, annotate the nodes in the figure\n    node_color : string\n        the color of the nodes\n    node_size : int\n        the size of the nodes\n    node_alpha : float\n        the opacity of the nodes\n    node_edgecolor : string\n        the color of the node's marker's border\n    node_zorder : int\n        zorder to plot nodes, edges are always 2, so make node_zorder 1 to plot\n        nodes beneath them or 3 to plot nodes atop them\n    edge_color : string\n        the color of the edges' lines\n    edge_linewidth : float\n        the width of the edges' lines\n    edge_alpha : float\n        the opacity of the edges' lines\n    use_geom : bool\n        if True, use the spatial geometry attribute of the edges to draw\n        geographically accurate edges, rather than just lines straight from node\n        to node\n    Returns\n    -------\n    fig, ax : tuple\n    "
    node_Xs = [float(x) for (_, x) in G.nodes(data='x')]
    node_Ys = [float(y) for (_, y) in G.nodes(data='y')]
    if (bbox is None):
        edges = graph_to_gdfs(G, nodes=False, fill_edge_geometry=True)
        (west, south, east, north) = edges.total_bounds
    else:
        (north, south, east, west) = bbox
    bbox_aspect_ratio = ((north - south) / (east - west))
    if (fig_width is None):
        fig_width = (fig_height / bbox_aspect_ratio)
    (fig, ax) = plt.subplots(figsize=(fig_width, fig_height), facecolor=bgcolor)
    ax.set_facecolor(bgcolor)
    start_time = time.time()
    lines = []
    for (u, v, data) in G.edges(keys=False, data=True):
        if (('geometry' in data) and use_geom):
            (xs, ys) = data['geometry'].xy
            lines.append(list(zip(xs, ys)))
        else:
            x1 = G.nodes[u]['x']
            y1 = G.nodes[u]['y']
            x2 = G.nodes[v]['x']
            y2 = G.nodes[v]['y']
            line = [(x1, y1), (x2, y2)]
            lines.append(line)
    lc = LineCollection(lines, colors=edge_color, linewidths=edge_linewidth, alpha=edge_alpha, zorder=2)
    ax.add_collection(lc)
    ax.scatter(node_Xs, node_Ys, s=node_size, c=node_color, alpha=node_alpha, edgecolor=node_edgecolor, zorder=node_zorder)
    margin_ns = ((north - south) * margin)
    margin_ew = ((east - west) * margin)
    ax.set_ylim(((south - margin_ns), (north + margin_ns)))
    ax.set_xlim(((west - margin_ew), (east + margin_ew)))
    xaxis = ax.get_xaxis()
    yaxis = ax.get_yaxis()
    xaxis.get_major_formatter().set_useOffset(False)
    yaxis.get_major_formatter().set_useOffset(False)
    if axis_off:
        ax.axis('off')
        ax.margins(0)
        ax.tick_params(which='both', direction='in')
        xaxis.set_visible(False)
        yaxis.set_visible(False)
        fig.canvas.draw()
    if equal_aspect:
        ax.set_aspect('equal')
        fig.canvas.draw()
    elif (G.graph['crs'] == default_crs):
        coslat = np.cos(((((min(node_Ys) + max(node_Ys)) / 2.0) / 180.0) * np.pi))
        ax.set_aspect((1.0 / coslat))
        fig.canvas.draw()
    if annotate:
        for (node, data) in G.nodes(data=True):
            ax.annotate(node, xy=(data['x'], data['y']))
    (fig, ax) = save_and_show(fig, ax, save, show, close, file_format, dpi, axis_off, filename=filename)
    return (fig, ax)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 66:------------------- similar code ------------------ index = 73, score = 5.0 
def plot_pdos(self, ax: Optional[Axes]=None, to_plot: Optional[Dict[(str, List[str])]]=None, colors: Optional[Iterable]=None, plot_total_dos: Optional[bool]=True, xrange: Optional[Tuple[(float, float)]]=None, ymax: Optional[float]=None, scaling: Optional[Dict[(str, Dict[(str, float)])]]=None, split: bool=False, title: Optional[str]=None, title_loc: str='center', labels: bool=True, title_fontsize: int=16, legend_pos: str='outside') -> Figure:
    if (not ax):
        (fig, ax) = plt.subplots(1, 1, figsize=(8.0, 3.0))
    else:
        fig = None
    if (not colors):
        colors = mcd.TABLEAU_COLORS
    assert isinstance(colors, Iterable)
    color_iterator = (c for c in colors)
    if (not scaling):
        scaling = {}
    if xrange:
        e_range = ((self.energy >= xrange[0]) & (self.energy <= xrange[1]))
    else:
        e_range = np.ma.make_mask(self.energy)
    auto_ymax = 0.0
    if (not to_plot):
        to_plot = {}
        assert isinstance(self.species, Iterable)
        for s in set(self.species):
            to_plot[s] = ['s', 'p', 'd']
            if (self.lmax == 3):
                to_plot[s].append('f')
    for species in to_plot.keys():
        assert isinstance(self.species, Iterable)
        index = [i for (i, s) in enumerate(self.species) if (s == species)]
        for state in to_plot[species]:
            assert (state in ['s', 'p', 'd', 'f'])
            color = next(color_iterator)
            label = '{} {}'.format(species, state)
            up_dos = self.pdos_sum(atoms=index, l=state, spin='up')[e_range]
            down_dos = self.pdos_sum(atoms=index, l=state, spin='down')[e_range]
            if (species in scaling):
                if (state in scaling[species]):
                    up_dos *= scaling[species][state]
                    down_dos *= scaling[species][state]
                    label = '{} {} $\\times${}'.format(species, state, scaling[species][state])
            auto_ymax = max([auto_ymax, up_dos.max(), down_dos.max()])
            ax.plot(self.energy[e_range], up_dos, label=label, c=color)
            ax.plot(self.energy[e_range], (down_dos * (- 1.0)), c=color)
    if plot_total_dos:
        ax.fill_between(self.energy[e_range], self.tdos.up.values[e_range], (self.tdos.down.values[e_range] * (- 1.0)), facecolor=TABLEAU_GREY, alpha=0.2)
        auto_ymax = max([auto_ymax, self.tdos.up.values[e_range].max(), self.tdos.down.values[e_range].max()])
    if xrange:
        ax.set_xlim(xrange[0], xrange[1])
    if (not ymax):
        ymax = (1.1 * auto_ymax)
    ax.set_ylim(((- ymax) * 1.1), (ymax * 1.1))
    if (legend_pos == 'outside'):
        ax.legend(bbox_to_anchor=(1.01, 1.04), loc='upper left')
    else:
        ax.legend(loc=legend_pos)
    if labels:
        ax.set_xlabel('Energy [eV]')
    ax.axhline(y=0, c='lightgrey')
    ax.axes.grid(False, axis='y')
    ax.tick_params(axis='y', which='both', left=False, right=False, labelleft=False)
    if title:
        ax.set_title(title, loc=title_loc, fontdict={'fontsize': title_fontsize})
    return fig

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... () ->  ... :
    if:
 = plt.subplots

idx = 67:------------------- similar code ------------------ index = 32, score = 5.0 
def getAxis(axis):
    if (axis is not False):
        ax = axis
        fig = ax.figure.canvas
    else:
        (fig, ax) = plt.subplots()
    return (fig, ax)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
    if:    else:
 = plt.subplots()

idx = 68:------------------- similar code ------------------ index = 56, score = 5.0 
def getAxis(axis):
    if (axis is not False):
        ax = axis
        fig = ax.figure.canvas
    else:
        (fig, ax) = plt.subplots()
    return (fig, ax)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
    if:    else:
 = plt.subplots()

idx = 69:------------------- similar code ------------------ index = 21, score = 3.0 
def plot_comparison(extension):
    yolo_air_path = os.path.join(data_dir, 'comparison/run_search_yolo-air-run_env=size=14-in-colour=False-task=arithmetic-ops=addition_alg=yolo-air_duration=long_seed=0_2018_07_16_13_46_48/')
    air_path = os.path.join(data_dir, 'comparison/run_search_air-run_env=size=14-in-colour=False-task=arithmetic-ops=addition_alg=attend-infer-repeat_duration=long_seed=0_2018_07_24_13_02_34')
    dair_path = os.path.join(data_dir, 'comparison/run_search_dair-run_env=size=14-in-colour=False-task=arithmetic-ops=addition_alg=attend-infer-repeat_duration=long_seed=0_2018_07_10_09_22_24')
    baseline_path = os.path.join(data_dir, 'comparison/run_search_comparison-baseline_env=size=14-in-colour=False-task=arithmetic-ops=addition_alg=baseline_duration=oak_seed=0_2018_07_20_11_15_24/')
    fig = plt.figure(figsize=(5, 3.5))
    ax = plt.gca()
    y_func = (lambda y: (100 * y))
    (x, y, *yerr) = get_arithmetic_data([yolo_air_path], 'n_digits', '_test_AP', 0, 'ci95', y_func=y_func)
    line = ax.errorbar(x, y, yerr=yerr, label='SPAIR', marker='o', ls='-')
    line.lines[0].get_c()
    (x, y, *yerr) = get_arithmetic_data([air_path], 'n_digits', '_test_AP', 0, 'ci95', y_func=y_func)
    line = ax.errorbar(x, y, yerr=yerr, label='AIR', marker='^', ls='-.')
    line.lines[0].get_c()
    (x, y, *yerr) = get_arithmetic_data([dair_path], 'n_digits', 'AP', 0, 'ci95', y_func=y_func)
    line = ax.errorbar(x, y, yerr=yerr, label='DAIR', marker='v', ls='--')
    line.lines[0].get_c()
    (x, y, *yerr) = get_arithmetic_data([baseline_path], 'n_digits', '_test_AP', 0, 'ci95', y_func=y_func)
    ax.plot(x, y, label='ConnComp', marker='s', ls=':')
    ax.set_ylabel('Average Precision', fontsize=12)
    ax.set_xlabel('\\# Digits in Image', fontsize=12)
    ax.tick_params(axis='both', labelsize=14)
    ax.set_ylim((0.0, 105.0))
    ax.set_xticks(x)
    plt.legend(loc='upper right', handlelength=4)
    plt.subplots_adjust(left=0.12, bottom=0.13, right=0.99, top=0.99)
    plot_path = os.path.join(plot_dir, ('comparison/main.' + extension))
    os.makedirs(os.path.dirname(plot_path), exist_ok=True)
    fig.savefig(plot_path)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.3 
def  ... ( ... ):
    plt

idx = 70:------------------- similar code ------------------ index = 7, score = 3.0 
def save_plot(filename):
    plt.gca().set_axis_off()
    plt.subplots_adjust(top=1, bottom=0, right=1, left=0, hspace=0, wspace=0)
    plt.margins(0, 0)
    plt.gca().xaxis.set_major_locator(plt.NullLocator())
    plt.gca().yaxis.set_major_locator(plt.NullLocator())
    plt.savefig(filename, bbox_inches='tight', pad_inches=0)

------------------- similar code (pruned) ------------------ score = 0.3 
def  ... ( ... ):
    plt

idx = 71:------------------- similar code ------------------ index = 10, score = 3.0 
def _plot_reconstruction(self, updater, fetched):
    inp = fetched['inp']
    output = fetched['output']
    (_, image_height, image_width, _) = inp.shape
    obj = fetched['obj'].reshape(self.N, (- 1))
    anchor_box = updater.network.anchor_box
    (yt, xt, ys, xs) = np.split(fetched['normalized_box'], 4, axis=(- 1))
    (yt, xt, ys, xs) = coords_to_pixel_space(yt, xt, ys, xs, (image_height, image_width), anchor_box, top_left=True)
    box = np.concatenate([yt, xt, ys, xs], axis=(- 1))
    box = box.reshape(self.N, (- 1), 4)
    on_colour = np.array(to_rgb('xkcd:azure'))
    off_colour = np.array(to_rgb('xkcd:red'))
    for (n, (pred, gt)) in enumerate(zip(output, inp)):
        fig = plt.figure(figsize=(5, 5))
        ax = plt.gca()
        self.imshow(ax, gt)
        ax.set_axis_off()
        for (o, (top, left, height, width)) in zip(obj[n], box[n]):
            if ((not self.show_zero_boxes) and (o <= 1e-06)):
                continue
            colour = ((o * on_colour) + ((1 - o) * off_colour))
            rect = patches.Rectangle((left, top), width, height, linewidth=2, edgecolor=colour, facecolor='none')
            ax.add_patch(rect)
        plt.subplots_adjust(left=0.01, right=0.99, top=0.99, bottom=0.01, wspace=0.1, hspace=0.1)
        self.savefig(('ground_truth/' + str(n)), fig, updater, is_dir=False)

------------------- similar code (pruned) ------------------ score = 0.3 
def  ... ():
    for in:
        plt

idx = 72:------------------- similar code ------------------ index = 65, score = 3.0 
def plot_addition_old(extension):
    yolo_path = os.path.join(data_dir, 'addition/2stage/run_search_sample_complexity_experiment_yolo_air_VS_nips_2018_addition_14x14_kind=long_cedar_seed=0_2018_05_14_03_04_29')
    yolo_supplement_path = os.path.join(data_dir, 'addition/2stage/run_search_supplement_sample_complexity_experiment_yolo_air_VS_nips_2018_addition_14x14_kind=supplement_seed=0_2018_05_14_14_18_26')
    simple_path = os.path.join(data_dir, 'addition/simple/run_search_sample_complexity-size=14_colour=False_task=addition_alg=yolo_math_simple_duration=long_seed=0_2018_05_14_23_59_50')
    simple_2stage_path = os.path.join(data_dir, 'addition/simple_2stage/run_search_sample_complexity-size=14_colour=False_task=addition_alg=yolo_math_simple_2stage_duration=long_seed=0_2018_05_15_12_55_38')
    fig = plt.figure(figsize=(5, 3.5))
    ax = plt.gca()
    measure = 'math_accuracy'
    (x, y, *yerr) = get_arithmetic_data([yolo_path, yolo_supplement_path], 'n_train', measure, 1, 'ci95')
    label = 'SI-AIR'
    ax.errorbar(x, y, yerr=yerr, label=label)
    (x, y, *yerr) = get_arithmetic_data([simple_path], 'n_train', measure, 0, 'ci95')
    label = 'Conv'
    ax.errorbar(x, y, yerr=yerr, label=label)
    (x, y, *yerr) = get_arithmetic_data([simple_2stage_path], 'n_train', measure, 0, 'ci95')
    label = 'Conv - 2stage'
    ax.errorbar(x, y, yerr=yerr, label=label)
    ax.set_ylabel('Accuracy', fontsize=12)
    ax.set_xlabel('\\# Training Samples / 1000', fontsize=12)
    ax.set_title('Addition - Between 1 and 11 numbers', fontsize=12)
    ax.tick_params(axis='both', labelsize=14)
    ax.set_ylim((0.0, 1.05))
    ax.set_xticks(x)
    ax.set_xticklabels((np.array(x) / 1000).astype('i'))
    plt.legend(loc='upper left')
    plot_path = os.path.join(plot_dir, ('addition/main.' + extension))
    os.makedirs(os.path.dirname(plot_path), exist_ok=True)
    plt.subplots_adjust(left=0.12, bottom=0.14, right=0.98, top=0.91)
    fig.savefig(plot_path)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.3 
def  ... ( ... ):
    plt

idx = 73:------------------- similar code ------------------ index = 29, score = 3.0 
def plot_addition(extension):
    air_fixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=fixed_alg=air-math_duration=long_seed=0_2018_07_29_09_58_58/')
    baseline_fixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=fixed_alg=baseline-math_duration=long_seed=0_2018_07_28_22_01_21/')
    ground_truth_fixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=fixed_alg=ground-truth-math_duration=long_seed=0_2018_07_28_22_02_14/')
    simple_fixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=fixed_alg=simple-math_duration=long_seed=0_2018_07_28_22_03_18/')
    yolo_air_fixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=fixed_alg=yolo-air-math_duration=long_seed=0_2018_07_28_22_04_04/')
    baseline_raw_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=raw_alg=baseline-math_duration=long_seed=0_2018_07_28_22_00_58/')
    ground_truth_raw_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=raw_alg=ground-truth-math_duration=long_seed=0_2018_07_28_22_01_56/')
    simple_raw_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=raw_alg=simple-math_duration=long_seed=0_2018_07_28_22_02_59/')
    air_unfixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=unfixed_alg=air-math_duration=long_seed=0_2018_07_29_09_58_32/')
    baseline_unfixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=unfixed_alg=baseline-math_duration=long_seed=0_2018_07_28_22_01_39/')
    ground_truth_unfixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=unfixed_alg=ground-truth-math_duration=long_seed=0_2018_07_28_22_02_30/')
    simple_unfixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=unfixed_alg=simple-math_duration=long_seed=0_2018_07_28_22_03_41/')
    yolo_air_unfixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=unfixed_alg=yolo-air-math_duration=long_seed=0_2018_07_28_22_04_21/')
    fig = plt.figure(figsize=(5, 4.5))
    ax = plt.gca()
    (x, y, *yerr) = get_arithmetic_data([baseline_raw_path], 'n_train', '_test_math_accuracy', 0, 'ci95')
    line = ax.errorbar(x, y, yerr=yerr, label='ConnComp', marker='o', ls='-')
    (x, y, *yerr) = get_arithmetic_data([ground_truth_raw_path], 'n_train', '_test_math_accuracy', 0, 'ci95')
    line = ax.errorbar(x, y, yerr=yerr, label='TrueBB', marker='^', ls='-')
    (x, y, *yerr) = get_arithmetic_data([simple_raw_path], 'n_train', '_test_math_accuracy', 0, 'ci95')
    line = ax.errorbar(x, y, yerr=yerr, label='ConvNet', marker='v', ls='-')
    (x, y, *yerr) = get_arithmetic_data([yolo_air_fixed_path], 'n_train', '_test_math_accuracy', 0, 'ci95')
    line = ax.errorbar(x, y, yerr=yerr, label='SPAIR - Fixed', marker='v', ls='-')
    yolo_air_color = line.lines[0].get_c()
    (x, y, *yerr) = get_arithmetic_data([yolo_air_unfixed_path], 'n_train', '_test_math_accuracy', 0, 'ci95')
    line = ax.errorbar(x, y, yerr=yerr, label='SPAIR - Unfixed', marker='v', ls='--', color=yolo_air_color)
    (x, y, *yerr) = get_arithmetic_data([air_fixed_path], 'n_train', '_test_math_accuracy', 0, 'ci95')
    line = ax.errorbar(x, y, yerr=yerr, label='AIR - Fixed', marker='o', ls='-')
    air_color = line.lines[0].get_c()
    (x, y, *yerr) = get_arithmetic_data([air_unfixed_path], 'n_train', '_test_math_accuracy', 0, 'ci95')
    line = ax.errorbar(x, y, yerr=yerr, label='AIR - Unfixed', marker='o', ls='--', color=air_color)
    ax.set_ylabel('Accuracy')
    ax.set_xlabel('\\# Training Examples / 1000')
    ax.tick_params(axis='both')
    ax.set_ylim((0.0, 1.05))
    ax.set_xscale('log')
    ax.set_xticks(x)
    ax.set_xticklabels((np.array(x) / 1000).astype('i'))
    plt.legend(loc='lower center', handlelength=2.5, bbox_to_anchor=(0.5, 1.01), ncol=3, columnspacing=1)
    plt.subplots_adjust(left=0.1, bottom=0.1, right=0.99, top=0.82)
    plot_path = os.path.join(plot_dir, ('addition/main.' + extension))
    os.makedirs(os.path.dirname(plot_path), exist_ok=True)
    fig.savefig(plot_path)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.3 
def  ... ( ... ):
    plt

idx = 74:------------------- similar code ------------------ index = 31, score = 3.0 
def handler(self, fetch_target_vars):
    auc = fetch_target_vars[0]
    print('test metric auc: ', fetch_target_vars)
    global last_net_sent
    global last_net_recv
    global y_auc
    global y_cpu
    global y_memory
    global y_network_sent
    global y_network_recv
    global x
    mlflow.log_metric('network_bytes_sent_speed', (psutil.net_io_counters().bytes_sent - last_net_sent))
    mlflow.log_metric('network_bytes_recv_speed', (psutil.net_io_counters().bytes_recv - last_net_recv))
    y_network_sent.append(((psutil.net_io_counters().bytes_sent - last_net_sent) / 10))
    y_network_recv.append(((psutil.net_io_counters().bytes_recv - last_net_recv) / 10))
    last_net_sent = psutil.net_io_counters().bytes_sent
    last_net_recv = psutil.net_io_counters().bytes_recv
    mlflow.log_metric('cpu_usage_total', round((psutil.cpu_percent(interval=0) / 100), 3))
    y_cpu.append(round((psutil.cpu_percent(interval=0) / 100), 3))
    mlflow.log_metric('free_memory/GB', round((psutil.virtual_memory().free / ((1024.0 * 1024.0) * 1024.0)), 3))
    mlflow.log_metric('memory_usage', round(((psutil.virtual_memory().total - psutil.virtual_memory().free) / float(psutil.virtual_memory().total)), 3))
    y_memory.append(round(((psutil.virtual_memory().total - psutil.virtual_memory().free) / float(psutil.virtual_memory().total)), 3))
    if (auc == None):
        mlflow.log_metric('auc', 0.5)
        auc = [0.5]
    else:
        mlflow.log_metric('auc', auc[0])
    y_auc.append(auc)
    x_list.append(x)
    if (x >= 120):
        y_auc.pop(0)
        y_cpu.pop(0)
        y_memory.pop(0)
        y_network_recv.pop(0)
        y_network_sent.pop(0)
        x_list.pop(0)
    x += 10
    if (((x % 60) == 0) and (x != 0)):
        plt.subplot(221)
        plt.plot(x_list, y_auc)
        plt.title('auc')
        plt.grid(True)
        plt.subplot(222)
        plt.plot(x_list, y_cpu)
        plt.title('cpu_usage')
        plt.grid(True)
        plt.subplot(223)
        plt.plot(x_list, y_memory)
        plt.title('memory_usage')
        plt.grid(True)
        plt.subplot(224)
        plt.plot(x_list, y_network_sent, label='network_sent_speed')
        plt.plot(x_list, y_network_recv, label='network_recv_speed')
        plt.title('network_speed')
        plt.grid(True)
        plt.subplots_adjust(top=0.9, bottom=0.2, hspace=0.4, wspace=0.35)
        plt.legend(bbox_to_anchor=(0, (- 0.6)), loc='lower left', borderaxespad=0.0)
        temp_file_name = (('dashboard_' + time.strftime('%Y-%m-%d_%H:%M:%S', time.localtime(time.time()))) + '.png')
        plt.savefig(temp_file_name, dpi=250)
        sys.stdout.flush()
        plt.clf()
        os.system((('rm -f ' + str(mlflow.get_artifact_uri().split(':')[1])) + '/*.png'))
        mlflow.log_artifact(local_path=temp_file_name)
        sys.stdout.flush()
        os.system('rm -f ./*.png')
        sys.stdout.flush()
        logger.info(str(mlflow.get_artifact_uri().split(':')[1]))
        sys.stdout.flush()

------------------- similar code (pruned) ------------------ score = 0.3 
def  ... ():
    if:
        plt

idx = 75:------------------- similar code ------------------ index = 0, score = 3.0 
def plot_arithmetic(extension):
    yolo_path = os.path.join(data_dir, 'arithmetic/2stage/run_search_sample_complexity-size=14_colour=False_task=arithmetic_alg=yolo_math_2stage_duration=long_seed=0_2018_05_15_00_32_28')
    simple_path = os.path.join(data_dir, 'arithmetic/simple/run_search_sample_complexity-size=14_colour=False_task=arithmetic_alg=yolo_math_simple_duration=long_seed=0_2018_05_15_00_01_16')
    simple_2stage_path = os.path.join(data_dir, 'arithmetic/simple_2stage/run_search_sample_complexity-size=14_colour=False_task=arithmetic_alg=yolo_math_simple_2stage_duration=long_seed=0_2018_05_15_12_59_19')
    fig = plt.figure(figsize=(5, 3.5))
    ax = plt.gca()
    measure = 'math_accuracy'
    (x, y, *yerr) = get_arithmetic_data([yolo_path], 'n_train', measure, 1, 'ci95')
    label = 'SI-AIR'
    ax.errorbar(x, y, yerr=yerr, label=label)
    (x, y, *yerr) = get_arithmetic_data([simple_path], 'n_train', measure, 0, 'ci95')
    label = 'Conv'
    ax.errorbar(x, y, yerr=yerr, label=label)
    (x, y, *yerr) = get_arithmetic_data([simple_2stage_path], 'n_train', measure, 0, 'ci95')
    label = 'Conv - 2stage'
    ax.errorbar(x, y, yerr=yerr, label=label)
    ax.set_ylabel('Accuracy', fontsize=12)
    ax.set_xlabel('# Training Samples / 1000', fontsize=12)
    ax.set_title('Arithmetic - Between 1 and 11 numbers', fontsize=12)
    ax.tick_params(axis='both', labelsize=14)
    ax.set_ylim((0.0, 1.05))
    ax.set_xticks(x)
    ax.set_xticklabels((np.array(x) / 1000).astype('i'))
    plt.legend(loc='upper left')
    plot_path = os.path.join(plot_dir, ('arithmetic/main.' + extension))
    os.makedirs(os.path.dirname(plot_path), exist_ok=True)
    plt.subplots_adjust(left=0.12, bottom=0.14, right=0.98, top=0.91)
    fig.savefig(plot_path)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.3 
def  ... ( ... ):
    plt

