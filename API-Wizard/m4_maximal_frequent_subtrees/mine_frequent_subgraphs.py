import re
from m4_maximal_frequent_subtrees.mine_frequent_subgraphs_helper import mine_frequent_subgraphs_helper
from helpers.representing_trees import representing_trees
from m4_maximal_frequent_subtrees.parallel_bfs_supgraphs_helper import parallel_bfs_supgraphs_helper

#This functions takes as array of the frequent patterns generated by the gspan and
#removes the subgraphs (if their set of vertices and edges are a subset of another larger graph)
#returns a list of the maximal frequent subgraphs

def mine_frequent_subgraphs(frequent_subgraphs):
   # Initialize dictionaries to store the  vertices of large and small trees
  lg_v = {}
  sm_v = {}

  # Call the mine_frequent_subgraphs_helper function to preprocess the frequent_subgraphs
  # and obtain the where_code_output
  frequent_subgraphs, where_code_output = mine_frequent_subgraphs_helper(frequent_subgraphs)
  # Sort the frequent_subgraphs based on their length
  frequent_subgraphs.sort(key=lambda x: len(x))


  # Initialize pointers for small and large subgraphs
  sml_pointer = 0
  lg_pointer = len(frequent_subgraphs) - 1


  # Iterate until the small pointer reaches the end of the frequent_subgraphs list
  while sml_pointer < len(frequent_subgraphs):
    sml_pointer_temp= sml_pointer
    while sml_pointer < lg_pointer:

        # Obtain the large and small vertices, as well as the large and small edges
        lg_v, sm_v, lg_edges, sm_edges = representing_trees(frequent_subgraphs[lg_pointer], frequent_subgraphs[sml_pointer])
       
        # Check if the large subgraph is a subgraph of the small subgraph using parallel BFS
        if parallel_bfs_supgraphs_helper(lg_v, sm_v, lg_edges, sm_edges ):
           # If the large subgraph is a subgraph, remove the small subgraph from the list
          frequent_subgraphs.pop(sml_pointer)
          lg_pointer = len(frequent_subgraphs) - 1
          
        else:
          lg_pointer -= 1

     # Move the small pointer to the next position and reset the large pointer
    sml_pointer = sml_pointer_temp+1
    lg_pointer = len(frequent_subgraphs) - 1

 # Filter the where_code_output based on the remaining frequent_subgraphs
  filtered_where_code_output = []
  for fg  in frequent_subgraphs:

    # Extract the index from the frequent_subgraph using regular expression
    match = re.search(r"t # (\d+)", fg)
    if match:
      index = int(match.group(1))
       # Append the corresponding where_code_output to the filtered list
      filtered_where_code_output.append(where_code_output[index])


  # Return the maximal frequent_subgraphs and filtered_where_code_output
  return frequent_subgraphs, filtered_where_code_output