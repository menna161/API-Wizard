------------------------- example 1 ------------------------ 
if (__name__ == '__main__'):
    import os
// your code ...

    for diff in tf.range(16):
        print(diff)
// your code ...

        (fig, axes) = plt.subplots(2, 2)
        x = (x - tf.math.reduce_min(x))
// your code ...

        axes[0][0].imshow(x[0])
        axes[0][1].imshow(x[1])
        axes[1][0].imshow(x[2])
// your code ...

        plt.savefig(f'noise_{diff}.png')

------------------------- example 2 ------------------------ 
def view3d_image(input_im, cmap='gray', title='', spacing=None, slice_axis=0):
    if (spacing is None):
// your code ...

    if (slice_axis == 0):
        aspect = (spacing[1] / spacing[2])
    elif (slice_axis == 1):
        input_numpy = np.transpose(input_numpy, [1, 0, 2])
        aspect = (spacing[0] / spacing[2])
    elif (slice_axis == 2):
        input_numpy = np.transpose(input_numpy, [2, 0, 1])
        aspect = (spacing[0] / spacing[1])
    else:
// your code ...

    (fig, ax) = plt.subplots(1, 1)
    tracker = IndexTracker(ax, input_numpy, cmap=cmap, title=title, aspect=aspect)
    fig.canvas.mpl_connect('scroll_event', tracker.onscroll)
// your code ...


------------------------- example 3 ------------------------ 
def _plot_reconstruction(self, updater, fetched):
    inp = fetched['inp']
// your code ...

    (fig, axes) = plt.subplots(sqrt_N, (3 * sqrt_N), figsize=(fig_width, fig_height))
    for (n, (pred, gt)) in enumerate(zip(output, inp)):
        i = int((n / sqrt_N))
// your code ...

        ax.set_axis_off()
        self.imshow(ax, gt)
// your code ...

        ax = axes[(i, ((3 * j) + 1))]
        ax.set_axis_off()
// your code ...

    plt.subplots_adjust(left=0, right=1, top=0.9, bottom=0, wspace=0.1, hspace=0.2)
    self.savefig('sampled_reconstruction', fig, updater)

------------------------- example 4 ------------------------ 
def plot_ablation(extension):
    yolo_path_n_lookback_0 = os.path.join(data_dir, 'ablation/run_search_yolo-air-ablation-n-lookback=0_env=task=scatter_alg=yolo-air-transfer_duration=long_seed=0_2018_09_03_08_52_37/')
// your code ...

    (fig, axes) = plt.subplots(1, 3, figsize=(8, 2.2))
    ax = axes[0]
    y_func = (lambda y: (100 * y))
// your code ...

    for ((x, y, *yerr), key) in nb0_data:
        if (not key_filter(key)):
// your code ...

        ax.errorbar(x, y, yerr=yerr, label=label)
    nb1_data = get_transfer_data(yolo_path_n_lookback_1, 'n_train', measure, 'ci95', y_func=y_func)
    for ((x, y, *yerr), key) in nb1_data:
        if (not key_filter(key)):
// your code ...

        ax.errorbar(x, y, yerr=yerr, label=label)
    fontsize = None
// your code ...

    ax.set_ylabel('Average Precision', fontsize=fontsize)
    ax.tick_params(axis='both', labelsize=labelsize)
    ax.set_ylim((0.0, 105.0))
    ax.set_xlabel('\\# Digits in Test Image', fontsize=fontsize)
    ax.set_xticks([0, 5, 10, 15, 20])
    ax.legend(loc='lower left', fontsize=8)
    ax = axes[1]
    measure = '_test_count_1norm'
// your code ...

    ax.tick_params(axis='both', labelsize=labelsize)
    ax.set_ylim((0.0, 4.0))
    ax.set_xticks([0, 5, 10, 15, 20])
    ax = axes[2]
// your code ...

    fig.savefig(plot_path)
    plt.show()

------------------------- example 5 ------------------------ 
def animate_activities(trajectory_or_activities, title='', shape=None, save=False, interval=50, colormap='Greys', vmin=None, vmax=None, show_grid=False, show_margin=True, scale=0.6, dpi=80, blit=True, with_timestep=False):
    if (len(trajectory_or_activities) is 0):
// your code ...

    (fig, ax) = plt.subplots()
    title_text = plt.title(title)
// your code ...

    if show_grid:
        plt.xticks(np.arange((- 0.5), len(activities[0][0]), 1), '')
// your code ...

        plt.tick_params(axis='both', which='both', length=0)
        grid_linewidth = 0.5
    vertical = np.arange((- 0.5), len(activities[0][0]), 1)
// your code ...

    ax.add_collection(grid)
    im = plt.imshow(activities[0], animated=True, cmap=cmap, vmin=vmin, vmax=vmax)
// your code ...

    ani = animation.FuncAnimation(fig, updatefig, interval=interval, blit=blit, save_count=len(activities))
    if save:
// your code ...


examples  ||  representativeness  ||  number of lines  || number of comments 
example1  ||          4           ||        14         ||         4        
example2  ||          4           ||        17         ||         3        
example3  ||          5           ||        15         ||         4        
example4  ||          4           ||        34         ||         7        
example5  ||          4           ||        19         ||         6        

avg       ||          4.2           ||        19.8         ||         4.8        

idx = 0:------------------- similar code ------------------ index = 3, score = 6.0 
@exp.automain
def compute_components(n_components, batch_size, learning_rate, method, reduction, alpha, step_size, n_jobs, n_epochs, verbose, source, _run):
    basedir = join(_run.observers[0].basedir, str(_run._id))
    artifact_dir = join(basedir, 'artifacts')
    if (not os.path.exists(artifact_dir)):
        os.makedirs(artifact_dir)
    if (source == 'hcp'):
        train_size = None
        smoothing_fwhm = 3
        test_size = 2
        data_dir = get_data_dirs()[0]
        mask = fetch_hcp_mask()
        masker = MultiRawMasker(mask_img=mask, smoothing_fwhm=smoothing_fwhm, detrend=True, standardize=True)
        mapping = json.load(open(join(data_dir, 'HCP_unmasked/mapping.json'), 'r'))
        data = sorted(list(mapping.values()))
        data = list(map((lambda x: join(data_dir, x)), data))
        data = pd.DataFrame(data, columns=['filename'])
    else:
        smoothing_fwhm = 6
        train_size = 4
        test_size = 4
        raw_res_dir = join(get_output_dir(), 'unmasked', source)
        try:
            (masker, data) = get_raw_rest_data(raw_res_dir)
        except ValueError:
            raw_res_dir = join(get_output_dir(), 'unmask', source)
            (masker, data) = get_raw_rest_data(raw_res_dir)
    (train_imgs, test_imgs) = train_test_split(data, test_size=test_size, random_state=0, train_size=train_size)
    train_imgs = train_imgs['filename'].values
    test_imgs = test_imgs['filename'].values
    cb = rfMRIDictionaryScorer(test_imgs, info=_run.info)
    dict_fact = fMRIDictFact(method=method, mask=masker, verbose=verbose, n_epochs=n_epochs, n_jobs=n_jobs, random_state=1, n_components=n_components, smoothing_fwhm=smoothing_fwhm, learning_rate=learning_rate, batch_size=batch_size, reduction=reduction, step_size=step_size, alpha=alpha, callback=cb)
    dict_fact.fit(train_imgs)
    dict_fact.components_img_.to_filename(join(artifact_dir, 'components.nii.gz'))
    fig = plt.figure()
    display_maps(fig, dict_fact.components_img_)
    plt.savefig(join(artifact_dir, 'components.png'))
    (fig, ax) = plt.subplots(1, 1)
    ax.plot(cb.cpu_time, cb.score, marker='o')
    _run.info['time'] = cb.cpu_time
    _run.info['score'] = cb.score
    _run.info['iter'] = cb.iter
    plt.savefig(join(artifact_dir, 'score.png'))

------------------- similar code (pruned) ------------------ score = 0.5833333333333334 
def  ... ():
    plt
 =  ... .subplots

idx = 1:------------------- similar code ------------------ index = 20, score = 6.0 
def boxplot_tre(landmarks, exp_list, normalize=True, min1=20, max1=90, min2=20, max2=30, dash_line_exp=None, threshold=None, ylim=None):
    tre = dict()
    error = dict()
    fancy_name = dict()
    for exp in exp_list:
        tre[exp] = np.copy(landmarks[exp]['TRE'])
        error[exp] = np.copy(landmarks[exp]['Error'])
        fancy_name[exp] = landmarks[exp]['FancyName']
    if (threshold is None):
        ytick_value = [0, 5, 10, 15, min2, max2]
        ytick_label = ['0', '5', '10', '15', str(min1), str(max1)]
        title = 'TRE [mm] of all landmarks'
    else:
        affine_error = error['Affine']
        selected_landmarks = np.where(np.all((np.abs(affine_error) <= threshold), axis=1))
        for exp in exp_list:
            tre[exp] = tre[exp][selected_landmarks]
        ytick_value = [0, 5, 10, 15]
        ytick_label = [str(i) for i in ytick_value]
        while (ytick_value[(- 1)] < (threshold + 5)):
            ytick_value.append((ytick_value[(- 1)] + 5))
            ytick_label.append(str((ytick_value[(- 2)] + 5)))
        title = 'TRE [mm] of the capture range of {}'.format(threshold)
    if normalize:
        for exp in exp_list:
            ix = np.where((tre[exp] > min1))
            tre[exp][ix] = ((((tre[exp][ix] - min1) * (max2 - min1)) / (max1 - min2)) + min2)
    plt.rc('font', family='serif')
    (fig, ax) = plt.subplots(figsize=(15, 8))
    bplot1 = plt.boxplot([tre[exp] for exp in exp_list], patch_artist=True, notch=True)
    color_dict = color_constants.color_dict()
    color_keys = ['blue', 'springgreen', 'sapgreen', 'cyan2', 'peacock']
    color_list = [color_dict[color_key] for color_key in color_keys]
    for (i_patch, patch) in enumerate(bplot1['boxes']):
        if (i_patch == 0):
            color_i = 0
        elif (0 < i_patch < 3):
            color_i = 1
        elif (i_patch == 3):
            color_i = 2
        else:
            color_i = 3
        patch.set_facecolor(color_list[color_i])
    plt.xticks(np.arange(1, (len(exp_list) + 1)), [fancy_name[exp] for exp in exp_list], fontsize=16, rotation=90)
    plt.yticks(ytick_value, ytick_label, fontsize=24)
    if (dash_line_exp is not None):
        exp_i = np.where((np.array(exp_list) == dash_line_exp))
        plt.axhline(y=bplot1['boxes'][exp_i[0][0]]._path.vertices[(2, 1)], color='r', linestyle=':')
    if (ylim is not None):
        plt.ylim([0, ylim])
    plt.subplots_adjust(hspace=0, bottom=0.5)
    plt.title(title)
    plt.draw()

------------------- similar code (pruned) ------------------ score = 0.5833333333333334 
def  ... ():
    plt
 =  ... .subplots

idx = 2:------------------- similar code ------------------ index = 2, score = 6.0 
def table_tre(landmarks, exp_list, threshold=None):
    tre = dict()
    error = dict()
    fancy_name = dict()
    for exp in exp_list:
        tre[exp] = np.copy(landmarks[exp]['TRE'])
        error[exp] = np.copy(landmarks[exp]['Error'])
        fancy_name[exp] = landmarks[exp]['FancyName']
    tab = dict()
    latex_str = {}
    header_tab = ['exp', 'measure', 'measure_x', 'measure_y', 'measure_z']
    value_tab = np.empty([len(exp_list), 5], dtype=object)
    if (threshold is None):
        selected_landmarks = np.arange(len(landmarks[next(iter(landmarks))]['Error']))
    else:
        affine_error = error['Affine']
        selected_landmarks = np.where(np.all((np.abs(affine_error) <= threshold), axis=1))
        selected_landmarks = selected_landmarks[0]
    selected_landmarks = selected_landmarks.astype(np.int)
    for (i, exp) in enumerate(exp_list):
        tab[exp] = {}
        latex_str[exp] = (('&' + fancy_name[exp]) + ' &test ')
        tab[exp]['mean'] = np.mean(tre[exp][selected_landmarks])
        tab[exp]['std'] = np.std(tre[exp][selected_landmarks])
        value_tab[(i, 0)] = fancy_name[exp]
        value_tab[(i, 1)] = '${:.2f}\\pm{:.2f}$'.format(tab[exp]['mean'], tab[exp]['std'])
        latex_str[exp] += '&\\scriptsize${:.2f}\\pm{:.2f}$'.format(tab[exp]['mean'], tab[exp]['std'])
        for dim in range(3):
            tab[exp][('dim' + str(dim))] = {}
            tab[exp][('dim' + str(dim))]['mean'] = np.mean(np.abs([error[exp][k][dim] for k in selected_landmarks]))
            tab[exp][('dim' + str(dim))]['std'] = np.std(np.abs([error[exp][k][dim] for k in selected_landmarks]))
            value_tab[(i, (dim + 2))] = '${:.2f}\\pm{:.2f}$'.format(tab[exp][('dim' + str(dim))]['mean'], tab[exp][('dim' + str(dim))]['std'])
            latex_str[exp] += (' & ' + '\\scriptsize${:.2f}\\pm{:.2f}$'.format(tab[exp][('dim' + str(dim))]['mean'], tab[exp][('dim' + str(dim))]['std']))
        latex_str[exp] += '\\\\'
        print(latex_str[exp])
    plt.rc('font', family='serif')
    (fig, ax) = plt.subplots(figsize=(15, 8))
    fig.patch.set_visible(False)
    ax.table(cellText=value_tab, colLabels=header_tab, loc='center', colLoc='left', cellLoc='left', fontsize=50)
    ax.axis('off')
    ax.axis('tight')
    fig.tight_layout()
    if threshold:
        plt.title('TRE [mm] of the capture range of {}'.format(threshold))
    plt.draw()

------------------- similar code (pruned) ------------------ score = 0.5833333333333334 
def  ... ():
    plt
 =  ... .subplots

idx = 3:------------------- similar code ------------------ index = 30, score = 6.0 
if (__name__ == '__main__'):
    import os
    os.environ['CUDA_DEVICE_ORDER'] = 'PCI_BUS_ID'
    os.environ['CUDA_VISIBLE_DEVICES'] = ''
    img = imageio.imread('kitty.jpg')
    img = (tf.cast(img, tf.float32) / 255.0)
    imgs = tf.tile(img[tf.newaxis], [4, 1, 1, 1])
    channel = get_noisy_channel()
    for diff in tf.range(16):
        print(diff)
        x = channel(imgs, diff)
        (fig, axes) = plt.subplots(2, 2)
        x = (x - tf.math.reduce_min(x))
        x = (x / tf.math.reduce_max(x))
        axes[0][0].imshow(x[0])
        axes[0][1].imshow(x[1])
        axes[1][0].imshow(x[2])
        axes[1][1].imshow(x[3])
        plt.savefig(f'noise_{diff}.png')

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
if:
    for  ...  in:
 = plt.subplots

idx = 4:------------------- similar code ------------------ index = 8, score = 6.0 
def view3d_image(input_im, cmap='gray', title='', spacing=None, slice_axis=0):
    if (spacing is None):
        spacing = [1, 1, 1]
    if isinstance(input_im, sitk.Image):
        input_numpy = sitk.GetArrayFromImage(input_im)
        spacing = input_im.GetSpacing()[::(- 1)]
    else:
        input_numpy = input_im
    if (slice_axis == 0):
        aspect = (spacing[1] / spacing[2])
    elif (slice_axis == 1):
        input_numpy = np.transpose(input_numpy, [1, 0, 2])
        aspect = (spacing[0] / spacing[2])
    elif (slice_axis == 2):
        input_numpy = np.transpose(input_numpy, [2, 0, 1])
        aspect = (spacing[0] / spacing[1])
    else:
        raise ValueError((('slice_axis = ' + str(slice_axis)) + ', but it should be in range of [0, 1, 2]'))
    (fig, ax) = plt.subplots(1, 1)
    tracker = IndexTracker(ax, input_numpy, cmap=cmap, title=title, aspect=aspect)
    fig.canvas.mpl_connect('scroll_event', tracker.onscroll)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 5:------------------- similar code ------------------ index = 9, score = 6.0 
def _plot_reconstruction(self, updater, fetched):
    inp = fetched['inp']
    output = fetched['output']
    prediction = fetched.get('prediction', None)
    targets = fetched.get('targets', None)
    sqrt_N = int(np.ceil(np.sqrt(self.N)))
    fig_height = 20
    fig_width = (4.5 * fig_height)
    (fig, axes) = plt.subplots(sqrt_N, (3 * sqrt_N), figsize=(fig_width, fig_height))
    for (n, (pred, gt)) in enumerate(zip(output, inp)):
        i = int((n / sqrt_N))
        j = int((n % sqrt_N))
        ax = axes[(i, (3 * j))]
        ax.set_axis_off()
        self.imshow(ax, gt)
        if (targets is not None):
            _target = targets[n]
            _prediction = prediction[n]
            title = 'target={}, prediction={}'.format(np.argmax(_target), np.argmax(_prediction))
            ax.set_title(title)
        ax = axes[(i, ((3 * j) + 1))]
        ax.set_axis_off()
        self.imshow(ax, pred)
        ax = axes[(i, ((3 * j) + 2))]
        ax.set_axis_off()
        diff = (np.abs((gt - pred)).sum(2) / 3)
        self.imshow(ax, diff)
    plt.subplots_adjust(left=0, right=1, top=0.9, bottom=0, wspace=0.1, hspace=0.2)
    self.savefig('sampled_reconstruction', fig, updater)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 6:------------------- similar code ------------------ index = 10, score = 6.0 
def _plot_reconstruction(self, updater, fetched):
    inp = fetched['inp']
    output = fetched['output']
    (_, image_height, image_width, _) = inp.shape
    obj = fetched['obj'].reshape(self.N, (- 1))
    anchor_box = updater.network.anchor_box
    (yt, xt, ys, xs) = np.split(fetched['normalized_box'], 4, axis=(- 1))
    (yt, xt, ys, xs) = coords_to_pixel_space(yt, xt, ys, xs, (image_height, image_width), anchor_box, top_left=True)
    box = np.concatenate([yt, xt, ys, xs], axis=(- 1))
    box = box.reshape(self.N, (- 1), 4)
    pred_colour = np.array(to_rgb(self.pred_colour))
    if self.do_annotations:
        n_annotations = fetched.get('n_annotations', ([0] * self.N))
        annotations = fetched.get('annotations', None)
        gt_colour = np.array(to_rgb(self.gt_colour))
    cutoff = 0.5
    for (n, (pred, gt)) in enumerate(zip(output, inp)):
        (fig, axes) = plt.subplots(1, 3, figsize=(6, 3))
        axes = np.array(axes).reshape(3)
        ax1 = axes[0]
        self.imshow(ax1, gt)
        ax2 = axes[1]
        self.imshow(ax2, pred)
        ax3 = axes[2]
        self.imshow(ax3, pred)
        for (o, (top, left, height, width)) in zip(obj[n], box[n]):
            if (o > cutoff):
                rect = patches.Rectangle((left, top), width, height, linewidth=2, edgecolor=pred_colour, facecolor='none')
                ax3.add_patch(rect)
        if self.do_annotations:
            for k in range(n_annotations[n]):
                (valid, _, _, top, bottom, left, right) = annotations[n][k]
                if (not valid):
                    continue
                height = (bottom - top)
                width = (right - left)
                rect = patches.Rectangle((left, top), width, height, linewidth=1, edgecolor=gt_colour, facecolor='none')
                ax3.add_patch(rect)
        for ax in axes.flatten():
            ax.set_axis_off()
        plt.subplots_adjust(left=0.02, right=0.98, top=0.98, bottom=0.02, wspace=0.1, hspace=0.1)
        self.savefig(('sampled_reconstruction/' + str(n)), fig, updater)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    for in:
 = plt.subplots

idx = 7:------------------- similar code ------------------ index = 11, score = 6.0 
def plot_ablation(extension):
    yolo_path_n_lookback_0 = os.path.join(data_dir, 'ablation/run_search_yolo-air-ablation-n-lookback=0_env=task=scatter_alg=yolo-air-transfer_duration=long_seed=0_2018_09_03_08_52_37/')
    yolo_path_n_lookback_1 = os.path.join(data_dir, 'ablation/run_search_yolo-air-ablation-n-lookback=1_env=task=scatter_alg=yolo-air-transfer_duration=long_seed=0_2018_09_03_09_00_25/')
    (fig, axes) = plt.subplots(1, 3, figsize=(8, 2.2))
    ax = axes[0]
    y_func = (lambda y: (100 * y))
    measure = '_test_AP'
    key_filter = (lambda key: (key.min_chars not in [1, 6]))
    nb0_data = get_transfer_data(yolo_path_n_lookback_0, 'n_train', measure, 'ci95', y_func=y_func)
    for ((x, y, *yerr), key) in nb0_data:
        if (not key_filter(key)):
            continue
        label = 'No Lateral Conns, {}--{} digits'.format(key.min_chars, key.max_chars)
        ax.errorbar(x, y, yerr=yerr, label=label)
    nb1_data = get_transfer_data(yolo_path_n_lookback_1, 'n_train', measure, 'ci95', y_func=y_func)
    for ((x, y, *yerr), key) in nb1_data:
        if (not key_filter(key)):
            continue
        label = 'With Lateral Conns, {}--{} digits'.format(key.min_chars, key.max_chars)
        ax.errorbar(x, y, yerr=yerr, label=label)
    fontsize = None
    labelsize = None
    ax.set_ylabel('Average Precision', fontsize=fontsize)
    ax.tick_params(axis='both', labelsize=labelsize)
    ax.set_ylim((0.0, 105.0))
    ax.set_xlabel('\\# Digits in Test Image', fontsize=fontsize)
    ax.set_xticks([0, 5, 10, 15, 20])
    ax.legend(loc='lower left', fontsize=8)
    ax = axes[1]
    measure = '_test_count_1norm'
    nb0_data = get_transfer_data(yolo_path_n_lookback_0, 'n_train', measure, 'ci95')
    for ((x, y, *yerr), key) in nb0_data:
        if (not key_filter(key)):
            continue
        ax.errorbar(x, y, yerr=yerr)
    nb1_data = get_transfer_data(yolo_path_n_lookback_1, 'n_train', measure, 'ci95')
    for ((x, y, *yerr), key) in nb1_data:
        if (not key_filter(key)):
            continue
        ax.errorbar(x, y, yerr=yerr)
    ax.set_ylabel('Count Absolute Error', fontsize=fontsize)
    ax.set_xlabel('\\# Digits in Test Image', fontsize=fontsize)
    ax.tick_params(axis='both', labelsize=labelsize)
    ax.set_ylim((0.0, 4.0))
    ax.set_xticks([0, 5, 10, 15, 20])
    ax = axes[2]
    measure = '_test_count_error'
    nb0_data = get_transfer_data(yolo_path_n_lookback_0, 'n_train', measure, 'ci95')
    for ((x, y, *yerr), key) in nb0_data:
        if (not key_filter(key)):
            continue
        ax.errorbar(x, y, yerr=yerr)
    nb1_data = get_transfer_data(yolo_path_n_lookback_1, 'n_train', measure, 'ci95')
    for ((x, y, *yerr), key) in nb1_data:
        if (not key_filter(key)):
            continue
        ax.errorbar(x, y, yerr=yerr)
    ax.set_ylabel('Count 0-1 Error', fontsize=fontsize)
    ax.tick_params(axis='both', labelsize=labelsize)
    ax.set_ylim((0.0, 1.05))
    ax.set_xlabel('\\# Digits in Test Image', fontsize=fontsize)
    ax.set_xticks([0, 5, 10, 15, 20])
    plt.subplots_adjust(left=0.07, bottom=0.2, right=0.98, top=0.94, wspace=0.27)
    plot_path = os.path.join(plot_dir, ('ablation/main.' + extension))
    os.makedirs(os.path.dirname(plot_path), exist_ok=True)
    fig.savefig(plot_path)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
 = plt.subplots

idx = 8:------------------- similar code ------------------ index = 5, score = 6.0 
def animate_activities(trajectory_or_activities, title='', shape=None, save=False, interval=50, colormap='Greys', vmin=None, vmax=None, show_grid=False, show_margin=True, scale=0.6, dpi=80, blit=True, with_timestep=False):
    if (len(trajectory_or_activities) is 0):
        raise Exception('there are no activities')
    if isinstance(trajectory_or_activities[0], State):
        activities = get_activities_over_time_as_list(trajectory_or_activities)
    else:
        activities = trajectory_or_activities
    if (shape is not None):
        activities = _reshape_for_animation(activities, shape)
    cmap = plt.get_cmap(colormap)
    (fig, ax) = plt.subplots()
    title_text = plt.title(title)
    if (not show_margin):
        fig.subplots_adjust(left=0, bottom=0, right=1, top=1, wspace=0, hspace=0)
    grid_linewidth = 0.0
    if show_grid:
        plt.xticks(np.arange((- 0.5), len(activities[0][0]), 1), '')
        plt.yticks(np.arange((- 0.5), len(activities[0]), 1), '')
        plt.tick_params(axis='both', which='both', length=0)
        grid_linewidth = 0.5
    vertical = np.arange((- 0.5), len(activities[0][0]), 1)
    horizontal = np.arange((- 0.5), len(activities[0]), 1)
    lines = ([[(x, y) for y in ((- 0.5), horizontal[(- 1)])] for x in vertical] + [[(x, y) for x in ((- 0.5), vertical[(- 1)])] for y in horizontal])
    grid = mcoll.LineCollection(lines, linestyles='-', linewidths=grid_linewidth, color='grey')
    ax.add_collection(grid)
    im = plt.imshow(activities[0], animated=True, cmap=cmap, vmin=vmin, vmax=vmax)
    if (not show_margin):
        (baseheight, basewidth) = im.get_size()
        fig.set_size_inches((basewidth * scale), (baseheight * scale), forward=True)
    i = {'index': 0}

    def updatefig(*args):
        i['index'] += 1
        if (i['index'] == len(activities)):
            i['index'] = 0
        im.set_array(activities[i['index']])
        if with_timestep:
            title_text.set_text(('timestep: %s' % (i['index'] + 1)))
        return (im, grid, title_text)
    ani = animation.FuncAnimation(fig, updatefig, interval=interval, blit=blit, save_count=len(activities))
    if save:
        ani.save('evolved.gif', dpi=dpi, writer='imagemagick')
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots()

idx = 9:------------------- similar code ------------------ index = 4, score = 6.0 
def animate(self, save=False, interval=50, dpi=80, marker='', repeat=False, fps=50):
    (fig, ax) = plt.subplots()
    ax.set_aspect('equal')
    x_vals = [s[0] for s in self.trajectory]
    max_x = np.max(x_vals)
    min_x = np.min(x_vals)
    max_x += (0.05 * (max_x - min_x))
    min_x -= (0.05 * (max_x - min_x))
    y_vals = [s[1] for s in self.trajectory]
    max_y = np.max(y_vals)
    min_y = np.min(y_vals)
    max_y += (0.05 * (max_y - min_y))
    min_y -= (0.05 * (max_y - min_y))

    def update(t):
        plt.plot(self.trajectory[t][0], self.trajectory[t][1], marker=marker, color='black')
        if ((t == (len(self.trajectory) - 1)) and repeat):
            ax.clear()
            ax.xaxis.set_ticklabels([])
            ax.yaxis.set_ticklabels([])
            ax.set_xticks([])
            ax.set_yticks([])
            plt.xlim(min_x, max_x)
            plt.ylim(min_y, max_y)
    ani = animation.FuncAnimation(fig, update, frames=len(self.trajectory), interval=interval, save_count=len(self.trajectory), repeat=repeat)
    plt.xlim(min_x, max_x)
    plt.ylim(min_y, max_y)
    plt.gca().axes.xaxis.set_ticklabels([])
    plt.gca().axes.yaxis.set_ticklabels([])
    plt.xticks([])
    plt.yticks([])
    if save:
        ani.save('turtle.gif', dpi=dpi, writer='imagemagick', fps=fps)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots()

idx = 10:------------------- similar code ------------------ index = 14, score = 6.0 
def _plot_reconstruction(self, updater, fetched):
    inp = fetched['inp']
    output = fetched['output']
    prediction = fetched.get('prediction', None)
    targets = fetched.get('targets', None)
    (_, image_height, image_width, _) = inp.shape
    obj = fetched['obj'].reshape(self.N, (- 1))
    anchor_box = updater.network.anchor_box
    (yt, xt, ys, xs) = np.split(fetched['normalized_box'], 4, axis=(- 1))
    (yt, xt, ys, xs) = coords_to_pixel_space(yt, xt, ys, xs, (image_height, image_width), anchor_box, top_left=True)
    box = np.concatenate([yt, xt, ys, xs], axis=(- 1))
    box = box.reshape(self.N, (- 1), 4)
    n_annotations = fetched.get('n_annotations', ([0] * self.N))
    annotations = fetched.get('annotations', None)
    actions = fetched.get('actions', None)
    sqrt_N = int(np.ceil(np.sqrt(self.N)))
    on_colour = np.array(to_rgb('xkcd:azure'))
    off_colour = np.array(to_rgb('xkcd:red'))
    cutoff = 0.5
    (fig, axes) = plt.subplots((2 * sqrt_N), (2 * sqrt_N), figsize=(20, 20))
    axes = np.array(axes).reshape((2 * sqrt_N), (2 * sqrt_N))
    for (n, (pred, gt)) in enumerate(zip(output, inp)):
        i = int((n / sqrt_N))
        j = int((n % sqrt_N))
        ax1 = axes[((2 * i), (2 * j))]
        self.imshow(ax1, gt)
        title = ''
        if (prediction is not None):
            title += 'target={}, prediction={}'.format(np.argmax(targets[n]), np.argmax(prediction[n]))
        if (actions is not None):
            title += ', actions={}'.format(actions[(n, 0)])
        ax1.set_title(title)
        ax2 = axes[((2 * i), ((2 * j) + 1))]
        self.imshow(ax2, pred)
        ax3 = axes[(((2 * i) + 1), (2 * j))]
        self.imshow(ax3, pred)
        ax4 = axes[(((2 * i) + 1), ((2 * j) + 1))]
        self.imshow(ax4, pred)
        for (o, (top, left, height, width)) in zip(obj[n], box[n]):
            colour = ((o * on_colour) + ((1 - o) * off_colour))
            rect = patches.Rectangle((left, top), width, height, linewidth=2, edgecolor=colour, facecolor='none')
            ax4.add_patch(rect)
            if (o > cutoff):
                rect = patches.Rectangle((left, top), width, height, linewidth=2, edgecolor=colour, facecolor='none')
                ax3.add_patch(rect)
        for k in range(n_annotations[n]):
            (valid, _, _, top, bottom, left, right) = annotations[n][k]
            if (not valid):
                continue
            height = (bottom - top)
            width = (right - left)
            rect = patches.Rectangle((left, top), width, height, linewidth=1, edgecolor='xkcd:yellow', facecolor='none')
            ax1.add_patch(rect)
            rect = patches.Rectangle((left, top), width, height, linewidth=1, edgecolor='xkcd:yellow', facecolor='none')
            ax3.add_patch(rect)
            rect = patches.Rectangle((left, top), width, height, linewidth=1, edgecolor='xkcd:yellow', facecolor='none')
            ax4.add_patch(rect)
        for ax in axes.flatten():
            ax.set_axis_off()
    if (prediction is None):
        plt.subplots_adjust(left=0, right=1, top=1, bottom=0, wspace=0.1, hspace=0.1)
    else:
        plt.subplots_adjust(left=0, right=1, top=0.9, bottom=0, wspace=0.1, hspace=0.2)
    self.savefig('sampled_reconstruction', fig, updater)

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 11:------------------- similar code ------------------ index = 29, score = 6.0 
def animate_hex(trajectory, title='', shape=None, save=False, interval=50, colormap='Greys', vmin=None, vmax=None, edgecolor=None):
    activities = get_activities_over_time_as_list(trajectory)
    if (shape is not None):
        activities = np.reshape(activities, (len(activities), shape[0], shape[1]))
    triples = _get_triples(activities[0])
    has_odd_rows = ((len(activities[0]) % 2) != 0)
    (fig, ax) = plt.subplots(1)
    ax.set_aspect('equal')
    m = _get_scaled_colormap(triples, colormap, vmin, vmax)
    patches = []
    for t in triples:
        (x, y) = (_oddr_offset_to_pixel(t[0], t[1]) if has_odd_rows else _evenr_offset_to_pixel(t[0], t[1]))
        hex = RegularPolygon((x, y), numVertices=6, radius=1.0, orientation=np.radians(60), edgecolor=edgecolor)
        patches.append(hex)
    p = PatchCollection(patches, match_original=True, cmap=m.get_cmap())
    ax.add_collection(p)
    i = {'index': 0}

    def update(*args):
        i['index'] += 1
        if (i['index'] == len(activities)):
            i['index'] = 0
        new_triples = _get_triples(activities[i['index']])
        p.set_array(np.array([tr[2] for tr in new_triples]))
        return (p,)
    ax.scatter([t[0] for t in triples], [t[1] for t in triples], marker='')
    plt.gca().invert_yaxis()
    plt.title(title)
    ani = animation.FuncAnimation(fig, update, interval=interval, blit=True, save_count=len(activities))
    if save:
        ani.save('evolved.gif', dpi=80, writer='imagemagick')
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 12:------------------- similar code ------------------ index = 16, score = 6.0 
def table_box_plot(setting, landmarks, compare_list=None, fig_measure_list=None, plot_per_pair=False, fig_ext='.png', plot_folder=None, paper_table=None, naming_strategy=None, jacobian=False, multi_jac_exp_list=None):
    "\n    merge the landmarks from different cases\n    :param setting:\n    :param landmarks:\n    :param compare_list:\n    :param\n    :param plot_folder: one of the experiment to save all plots in that directory. The plot folder should consider also the stages\n    for example: my_experiment_S4_S2_S1. if None, the last experiment will be chosen as the plot folder\n    :param naming_strategy: None\n                            'Fancy'\n                            'Clean'\n    :param paper_table: 'SPREAD', 'DIR-Lab'\n    :return:\n    "
    if (multi_jac_exp_list is None):
        if (paper_table == 'SPREAD-Multi'):
            multi_jac_exp_list = ['2020_multistage_crop45_K_NoResp_SingleOnly_more_itr_S4_S2_S1', 'BSpline_S4_S2_S1']
            multi_jac_exp_list = []
        if (paper_table == 'DIR-Lab-Multi'):
            multi_jac_exp_list = ['2020_multistage_crop45_K_Resp_more_itr_S4_S2_S1']
    if (compare_list is None):
        compare_list = ['Affine', 'BSpline']
    if (fig_measure_list is None):
        fig_measure_list = ['TRE']
    landmarks_merged = dict()
    if (plot_folder is None):
        plot_key = list(landmarks.items())[(- 1)][0]
    else:
        plot_key = plot_folder
    split_plot_folder = plot_key.split('_S')
    stage_list = []
    plot_folder_key_pure = split_plot_folder[0]
    for split_str in split_plot_folder:
        if (len(split_str) == 1):
            stage_list.append(int(split_str))
    result_folder = su.address_generator(setting, 'result_detail_folder', current_experiment=plot_folder_key_pure, stage_list=stage_list, pair_info=landmarks[plot_key][0]['pair_info'])
    if (not os.path.isdir(result_folder)):
        os.makedirs(result_folder)
    xlsx_address = (result_folder + 'results.xlsx')
    workbook = xlsxwriter.Workbook(xlsx_address)
    worksheet = workbook.add_worksheet()
    line = 0
    header = {'exp': 0, 'TRE_Mean': 1, 'TRE_STD': 2, 'TRE_Median': 3, 'MAE0_Mean': 4, 'MAE0_STD': 5, 'MAE1_Mean': 6, 'MAE1_STD': 7, 'MAE2_Mean': 8, 'MAE2_STD': 9, 'Jac_FoldingPercentage': 10, 'Jac_STD': 11, 'Error0_Mean': 12, 'Error0_STD': 13, 'Error1_Mean': 14, 'Error1_STD': 15, 'Error2_Mean': 16, 'Error2_STD': 17}
    for key in header.keys():
        worksheet.write(line, header[key], key)
    num_exp = len(landmarks.keys())
    for (exp_i, exp) in enumerate(landmarks.keys()):
        landmarks_merged[exp] = {'TRE': np.empty([0]), 'Error': np.empty([0, 3]), 'CleanName': su.clean_exp_name(exp), 'FancyName': su.fancy_exp_name(exp), 'Jac_NumberOfNegativeJacVoxels': 0, 'Jac_MaskSize': 0, 'Jac_Var': 0, 'Jac_STD_List': [], 'Jac_FoldingPercentage_List': []}
        num_pair = len(landmarks[exp])
        for (pair_i, landmark_pair) in enumerate(landmarks[exp]):
            pair_info = landmark_pair['pair_info']
            pair_info_text = ((((((landmarks_merged[exp]['CleanName'] + '_Fixed_') + pair_info[0]['data']) + '_CN{}_TypeIm{},'.format(pair_info[0]['cn'], pair_info[0]['type_im'])) + '_Moving_') + pair_info[1]['data']) + '_CN{}_TypeIm{}'.format(pair_info[1]['cn'], pair_info[1]['type_im']))
            landmarks_merged[exp]['TRE'] = np.append(landmarks_merged[exp]['TRE'], landmark_pair['landmark_info']['TRE'])
            landmarks_merged[exp]['Error'] = np.vstack((landmarks_merged[exp]['Error'], landmark_pair['landmark_info']['Error']))
            if jacobian:
                if (paper_table is not None):
                    if (exp in multi_jac_exp_list):
                        landmarks_merged[exp]['Jac_NumberOfNegativeJacVoxels'] += landmark_pair['landmark_info']['Jac_NumberOfNegativeJacVoxels']
                        landmarks_merged[exp]['Jac_MaskSize'] += landmark_pair['landmark_info']['Jac_MaskSize']
                        landmarks_merged[exp]['Jac_Var'] += ((landmark_pair['landmark_info']['Jac_Var'] * 1) / len(landmarks[exp]))
                        landmarks_merged[exp]['Jac_STD_List'].append(np.sqrt(landmark_pair['landmark_info']['Jac_Var']))
                        landmarks_merged[exp]['Jac_FoldingPercentage_List'].append(((landmark_pair['landmark_info']['Jac_NumberOfNegativeJacVoxels'] / landmark_pair['landmark_info']['Jac_MaskSize']) * 100))
            measure = calculate_measure(landmark_pair['landmark_info'])
            measure['exp'] = pair_info_text
            if plot_per_pair:
                print_latex(measure)
            line = ((exp_i + (pair_i * (num_exp + 1))) + 1)
            for key in header.keys():
                if (key in measure.keys()):
                    worksheet.write(line, header[key], measure[key])
                    landmark_pair['landmark_info'][key] = measure[key]
        measure_merged = calculate_measure(landmarks_merged[exp])
        if (naming_strategy == 'Clean'):
            measure_merged['exp'] = su.clean_exp_name(exp)
        elif (naming_strategy == 'Fancy'):
            measure_merged['exp'] = su.fancy_exp_name(exp)
        else:
            measure_merged['exp'] = exp
        print_latex(measure_merged)
        line = ((exp_i + (num_pair * (num_exp + 1))) + 2)
        for key in header.keys():
            if (key in measure.keys()):
                if ((key in header.keys()) and (key in measure_merged.keys())):
                    worksheet.write(line, header[key], measure_merged[key])
    workbook.close()
    if (paper_table == 'SPREAD'):
        print_latex_spread(landmarks, landmarks_merged, plot_key)
    if (paper_table == 'DIR-Lab'):
        print_latex_dir_lab_4d(landmarks, landmarks_merged, plot_key)
    if (paper_table == 'SPREAD-Multi'):
        print_latex_spread_multiple(landmarks, landmarks_merged, multi_jac_exp_list)
    if (paper_table == 'DIR-Lab-Multi'):
        print_latex_dir_lab_4d_multiple(landmarks, landmarks_merged, multi_jac_exp_list)
    for measure in fig_measure_list:
        if plot_per_pair:
            for pair_i in range(len(landmarks[next(iter(landmarks))])):
                (fig, ax) = plt.subplots(figsize=(15, 8))
                bplot1 = plt.boxplot([landmarks[exp][pair_i]['landmark_info'][measure] for exp in landmarks.keys()], patch_artist=True, notch=True)
                title_name = landmarks[next(iter(landmarks))][pair_i]['landmark_info']['exp']
                plt.title(title_name)
                plt.draw()
                plt.savefig(((((result_folder + measure) + '_') + title_name) + fig_ext))
                plt.close()
        (fig, ax) = plt.subplots(figsize=(15, 8))
        bplot1 = plt.boxplot([landmarks_merged[exp][measure] for exp in landmarks_merged.keys()], patch_artist=True, notch=True)
        title_name = (measure + '_Merged')
        plt.title(title_name)
        plt.savefig(((((result_folder + measure) + '_') + title_name) + fig_ext))
        plt.draw()
        plt.close()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    for  ...  in  ... :
        if  ... :
            for  ...  in:
 = plt.subplots

idx = 13:------------------- similar code ------------------ index = 18, score = 6.0 
def save_traj(images, image_goal, gif_path, task):
    (fig, aa) = plt.subplots(1, 2)
    m1 = aa[0].matshow(images[0], cmap=plt.cm.gray, vmin=0.0, vmax=1.0)
    aa[0].set_title('Time step 0')
    aa[0].set_yticklabels([])
    aa[0].set_xticklabels([])
    m2 = aa[1].matshow(image_goal, cmap=plt.cm.gray, vmin=0.0, vmax=1.0)
    aa[1].set_title('goal')
    aa[1].set_yticklabels([])
    aa[1].set_xticklabels([])
    fig.tight_layout()

    def updatemat2(t):
        m1.set_data(images[t])
        aa[0].set_title(('Time step ' + str(t)))
        m2.set_data(image_goal)
        return (m1, m2)
    frames = len(images)
    if (task in ['plane', 'cartpole']):
        fps = 2
    else:
        fps = 20
    anim = FuncAnimation(fig, updatemat2, frames=frames, interval=200, blit=True, repeat=True)
    Writer = writers['imagemagick']
    writer = Writer(fps=fps, metadata=dict(artist='Me'), bitrate=1800)
    anim.save(gif_path, writer=writer)
    plt.clf()
    plt.cla()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 14:------------------- similar code ------------------ index = 19, score = 6.0 
def show_latent_map(model, mdp):
    true_map = get_true_map(mdp)
    latent_map = draw_latent_map(model, mdp)
    latent_map = (np.array(latent_map) / 255.0)
    (f, axarr) = plt.subplots(1, 2, figsize=(15, 15))
    axarr[0].imshow(true_map)
    axarr[1].imshow(latent_map)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 15:------------------- similar code ------------------ index = 21, score = 6.0 
def plot_transfer(extension):
    yolo_path = os.path.join(data_dir, 'transfer/run_search_yolo-air-transfer_env=size=14-in-colour=False-task=scatter_alg=yolo-air-transfer_duration=long_seed=0_2018_07_19_14_21_39/')
    baseline_path_ap = os.path.join(data_dir, 'transfer/run_search_transfer-baseline_env=size=14-in-colour=False-task=scatter_alg=baseline_duration=oak_seed=0_2018_07_20_11_27_19/')
    baseline_path_count_1norm = os.path.join(data_dir, 'transfer/run_search_transfer-baseline-sc=count-1norm_env=size=14-in-colour=False-task=scatter_alg=baseline_duration=oak_seed=0_2018_07_26_12_15_50/')
    baseline_path_count_error = os.path.join(data_dir, 'transfer/run_search_transfer-baseline-sc=count-error_env=size=14-in-colour=False-task=scatter_alg=baseline_duration=oak_seed=0_2018_07_26_12_29_21/')
    (fig, axes) = plt.subplots(1, 3, figsize=(8, 2.2))
    ax = axes[0]
    y_func = (lambda y: (100 * y))
    measure = '_test_AP'
    yolo_data = get_transfer_data(yolo_path, 'n_train', measure, 'ci95', y_func=y_func)
    for ((x, y, *yerr), key) in yolo_data:
        label = 'Trained on {}--{} digits'.format(key.min_chars, key.max_chars)
        ax.errorbar(x, y, yerr=yerr, label=label)
    (x, y) = get_transfer_baseline_data(baseline_path_ap, 'n_train', measure, 'ci95', y_func=y_func)
    ax.plot(x, y, label='ConnComp')
    fontsize = None
    labelsize = None
    ax.set_ylabel('Average Precision', fontsize=fontsize)
    ax.tick_params(axis='both', labelsize=labelsize)
    ax.set_ylim((0.0, 105.0))
    ax.set_xlabel('\\# Digits in Test Image', fontsize=fontsize)
    ax.set_xticks([0, 5, 10, 15, 20])
    ax.legend(loc='lower left', fontsize=8)
    ax = axes[1]
    measure = '_test_count_1norm'
    yolo_data = get_transfer_data(yolo_path, 'n_train', measure, 'ci95')
    for ((x, y, *yerr), key) in yolo_data:
        label = 'Trained on {}--{} digits'.format(key.min_chars, key.max_chars)
        ax.errorbar(x, y, yerr=yerr, label=label)
    (x, y) = get_transfer_baseline_data(baseline_path_count_1norm, 'n_train', measure, 'ci95')
    ax.plot(x, y, label='ConnComp')
    ax.set_ylabel('Count Absolute Error', fontsize=fontsize)
    ax.set_xlabel('\\# Digits in Test Image', fontsize=fontsize)
    ax.tick_params(axis='both', labelsize=labelsize)
    ax.set_ylim((0.0, 3.1))
    ax.set_xticks([0, 5, 10, 15, 20])
    ax = axes[2]
    measure = '_test_count_error'
    yolo_data = get_transfer_data(yolo_path, 'n_train', measure, 'ci95')
    for ((x, y, *yerr), key) in yolo_data:
        label = 'Trained on {}--{} digits'.format(key.min_chars, key.max_chars)
        ax.errorbar(x, y, yerr=yerr, label=label)
    (x, y) = get_transfer_baseline_data(baseline_path_count_error, 'n_train', measure, 'ci95')
    ax.plot(x, y, label='ConnComp')
    ax.set_ylabel('Count 0-1 Error', fontsize=fontsize)
    ax.tick_params(axis='both', labelsize=labelsize)
    ax.set_ylim((0.0, 1.05))
    ax.set_xlabel('\\# Digits in Test Image', fontsize=fontsize)
    ax.set_xticks([0, 5, 10, 15, 20])
    plt.subplots_adjust(left=0.07, bottom=0.2, right=0.98, top=0.94, wspace=0.27)
    plot_path = os.path.join(plot_dir, ('transfer/main.' + extension))
    os.makedirs(os.path.dirname(plot_path), exist_ok=True)
    fig.savefig(plot_path)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
 = plt.subplots

idx = 16:------------------- similar code ------------------ index = 22, score = 6.0 
def main():
    print(f'Using strategy: {strategy}')
    with strategy.scope():

        def vision_only_predict(model, batch, difficulty, perceptor):
            all_losses = {}
            symbols = batch
            (predictions, imgs, aug_imgs) = model(symbols, difficulty)
            acc = tf.keras.metrics.categorical_accuracy(symbols, predictions)
            acc = tf.math.reduce_mean(acc)
            acc = {'symbols': acc}
            lfn = (tf.keras.losses.mean_squared_error if CFG['use_mse_loss'] else (lambda true, pred: tf.keras.losses.categorical_crossentropy(true, pred, label_smoothing=CFG['label_smoothing'])))
            recon_loss = tf.keras.losses.categorical_crossentropy(symbols, predictions)
            recon_loss = tf.math.reduce_sum(recon_loss)
            all_losses['reconstruction'] = recon_loss
            if CFG['use_perceptual_loss']:
                features = perceptor(imgs)
                percept_loss = perceptual_loss(features)
                all_losses['perceptual'] = percept_loss
            if CFG['use_spy']:
                (predictions_s, imgs_s, aug_imgs_s) = model(symbols, difficulty, spy_turn=True)
                acc_s = tf.keras.metrics.categorical_accuracy(symbols, predictions_s)
                acc_s = tf.math.reduce_mean(acc_s)
                acc['spy_symbols'] = acc_s
                spy_loss = lfn(symbols, predictions_s)
                spy_loss = tf.math.reduce_sum(spy_loss)
            for sub_model in model.layers:
                name = sub_model.name
                all_losses[name] = tf.math.reduce_sum(sub_model.losses)
            loss_sum = 0.0
            for loss_name in all_losses.keys():
                loss_sum += all_losses[loss_name]
            if CFG['use_spy']:
                all_losses['spy_reconstruction'] = spy_loss
                all_losses['spy_scaled'] = tf.math.exp((spy_loss * (- 1)))
                loss_sum += all_losses['spy_scaled']
            return (loss_sum, acc, all_losses)

        def graph_or_full_predict(model, batch, difficulty, perceptor):
            all_losses = {}
            if CFG['VISION']:
                (adj_pred, nf_pred, imgs, aug_imgs, _, _) = model(batch, difficulty)
                (spy_adj_pred, spy_nf_pred, _, _, _, _) = model(batch, difficulty, spy_turn=True)
                if CFG['use_perceptual_loss']:
                    features = perceptor(imgs)
                    percept_loss = perceptual_loss(features)
                    all_losses['perceptual'] = percept_loss
            else:
                (adj_pred, nf_pred) = model(batch, difficulty)
                (spy_adj_pred, spy_nf_pred) = model(batch, difficulty, spy_turn=True)
            (recon_loss, acc) = minimum_loss_permutation(batch['adj_labels'], batch['nf_labels'], adj_pred, nf_pred)
            all_losses['reconstruction'] = recon_loss
            (spy_loss, spy_acc) = minimum_loss_permutation(batch['adj_labels'], batch['nf_labels'], spy_adj_pred, spy_nf_pred)
            for key in spy_acc.keys():
                acc[f'spy_{key}'] = spy_acc[key]
            for sub_model in model.layers:
                name = sub_model.name
                all_losses[name] = tf.math.reduce_sum(sub_model.losses)
            loss_sum = 0.0
            for loss_name in all_losses.keys():
                loss_sum += all_losses[loss_name]
            if CFG['use_spy']:
                all_losses['spy_reconstruction'] = spy_loss
                all_losses['spy_scaled'] = tf.math.exp((spy_loss * (- 1)))
                loss_sum += all_losses['spy_scaled']
            return (loss_sum, acc, all_losses)

        def predict(model, batch, difficulty, perceptor):
            if CFG['JUST_VISION']:
                (loss_sum, acc, all_losses) = vision_only_predict(model, batch, difficulty, perceptor)
            else:
                (loss_sum, acc, all_losses) = graph_or_full_predict(model, batch, difficulty, perceptor)
            return (loss_sum, acc, all_losses)

        @tf.function
        def train_step(batch, difficulty):
            with tf.GradientTape(persistent=True) as tape:
                (loss_sum, acc, all_losses) = predict(model, batch, difficulty, perceptor)
            grads = tape.gradient(loss_sum, model.trainable_variables)
            if CFG['TPU']:
                replica_ctx = tf.distribute.get_replica_context()
                grads = replica_ctx.all_reduce('mean', grads)
            optim.apply_gradients(zip(grads, model.trainable_variables))
            if CFG['use_spy']:
                spy_grads = tape.gradient(all_losses['spy_reconstruction'], model.spy.trainable_variables)
                if CFG['TPU']:
                    replica_ctx = tf.distribute.get_replica_context()
                    spy_grads = replica_ctx.all_reduce('mean', spy_grads)
                spy_optim.apply_gradients(zip(spy_grads, model.spy.trainable_variables))
            return (loss_sum, acc, all_losses)

        @tf.function
        def test_step(batch, difficulty):
            (batch_loss, acc, all_losses) = predict(model, batch, difficulty, perceptor)
            return (batch_loss, acc, all_losses)

        def aggregate_results(batch_loss, acc, all_losses):
            batch_loss = strategy.reduce('mean', batch_loss, axis=None)
            out_acc = {}
            out_all_losses = {}
            for key in acc.keys():
                out_acc[key] = strategy.reduce('mean', acc[key], axis=None)
            for key in all_losses.keys():
                out_all_losses[key] = strategy.reduce('mean', all_losses[key], axis=None)
            return (batch_loss, out_acc, out_all_losses)

        def step_fn(batch, difficulty, test=False):
            if test:
                if CFG['TPU']:
                    results = strategy.run(test_step, args=(batch, difficulty))
                    return aggregate_results(*results)
                else:
                    return test_step(batch, difficulty)
            elif CFG['TPU']:
                results = strategy.run(train_step, args=(batch, difficulty))
                return aggregate_results(*results)
            else:
                return train_step(batch, difficulty)
        if CFG['JUST_VISION']:
            (train_ds, _) = make_symbol_data(**CFG, test=False)
            (test_ds, _) = make_symbol_data(**CFG, test=True)
        else:
            (train_ds, _) = get_dataset(**CFG, test=False)
            (test_ds, _) = get_dataset(**CFG, test=True)
        replica_batch_size = CFG['batch_size']
        global_batch_size = (strategy.num_replicas_in_sync * replica_batch_size)
        tf_train_ds = tf.data.Dataset.from_tensor_slices(train_ds).batch(global_batch_size, drop_remainder=True)
        tf_test_ds = tf.data.Dataset.from_tensor_slices(test_ds).batch(global_batch_size, drop_remainder=True)
        path_prefix = CFG['root_filepath']
        model = get_model()
        run_dummy_batch(model)
        load_weights(model, path_prefix)
        optim = get_optim()
        spy_optim = get_spy_optim()
        perceptor = None
    difficulty = tf.convert_to_tensor(0)
    log_dir = f"logs/{CFG['run_name']}"
    os.makedirs(log_dir, exist_ok=True)
    train_log_dir = f'{path_prefix}{log_dir}/train'
    test_log_dir = f'{path_prefix}{log_dir}/test'
    train_summary_writer = tf.summary.create_file_writer(train_log_dir)
    test_summary_writer = tf.summary.create_file_writer(test_log_dir)
    current_time = str(datetime.datetime.now())
    CFG['current_time'] = current_time
    cfg_dir = os.path.join(log_dir, 'config.json')
    if CFG['USE_GS']:
        gs_upload_blob_from_string(json.dumps(CFG, indent=4), cfg_dir, print_str=True)
    else:
        with open(cfg_dir, 'w+') as f:
            f.write(json.dumps(CFG, indent=4))
    tr_num_samples = (train_ds.shape[0] if CFG['JUST_VISION'] else train_ds['adj'].shape[0])
    test_num_samples = (test_ds.shape[0] if CFG['JUST_VISION'] else test_ds['adj'].shape[0])
    tr_num_batches = (tr_num_samples // global_batch_size)
    test_num_batches = (test_num_samples // global_batch_size)
    best_epoch_loss = tf.float32.max
    for e_i in range(CFG['epochs']):
        tr_epoch_loss = 0
        test_epoch_loss = 0
        tr_epoch_acc = {}
        test_epoch_acc = {}
        all_losses = {}
        b_i = 0
        for train_batch in tf_train_ds:
            b_i += global_batch_size
            (batch_loss, batch_acc, batch_all_losses) = step_fn(train_batch, difficulty)
            tr_epoch_loss += batch_loss
            update_data_dict(tr_epoch_acc, batch_acc)
            update_data_dict(all_losses, batch_all_losses)
            print(f"(TRAIN) e [{e_i}/{CFG['epochs']}] b [{b_i}/{tr_num_samples}] loss {batch_loss}", end='\r')
        b_i = 0
        for test_batch in tf_test_ds:
            b_i += global_batch_size
            (batch_loss, batch_acc, _) = step_fn(test_batch, difficulty, test=True)
            test_epoch_loss += batch_loss
            update_data_dict(test_epoch_acc, batch_acc)
            print(f"(TEST) e [{e_i}/{CFG['epochs']}] b [{b_i}/{test_num_samples}] loss {batch_loss}", end='\r')
        tr_epoch_loss = (tr_epoch_loss / tr_num_batches)
        test_epoch_loss = (test_epoch_loss / test_num_batches)
        tr_epoch_acc = normalize_data_dict(tr_epoch_acc, tr_num_batches)
        test_epoch_acc = normalize_data_dict(test_epoch_acc, test_num_batches)
        all_losses = normalize_data_dict(all_losses, tr_num_batches)
        print(f'EPOCH {e_i} TRAIN LOSS: {tr_epoch_loss} TEST LOSS: {test_epoch_loss}')
        print(f'Train accuracies: {json.dumps(tr_epoch_acc, indent=4)}')
        print(f'Test accuracies: {json.dumps(test_epoch_acc, indent=4)}')
        print(f'All losses: {json.dumps(all_losses, indent=4)}')
        difficulty = update_difficulty(difficulty, tr_epoch_acc)
        print(f'DIFFICULTY FOR NEXT EPOCH: {difficulty}')
        if (not CFG['NOLOG']):
            with train_summary_writer.as_default():
                tf.summary.scalar('loss', tr_epoch_loss, step=e_i)
                for (name, metric) in tr_epoch_acc.items():
                    tf.summary.scalar(name, metric, step=e_i)
                for (name, specific_loss) in all_losses.items():
                    tf.summary.scalar(name, specific_loss, step=e_i)
            with test_summary_writer.as_default():
                tf.summary.scalar('loss', test_epoch_loss, step=e_i)
                for (name, metric) in test_epoch_acc.items():
                    tf.summary.scalar(name, metric, step=e_i)
        if (((e_i % CFG['save_checkpoint_every']) == 0) and (e_i != 0)):
            if (test_epoch_loss < best_epoch_loss):
                print(f'Saving checkpoint...')
                best_epoch_loss = test_epoch_loss
                save_weights(model, path_prefix)
        if (CFG['VISION'] and ((e_i % CFG['image_every']) == 0) and (e_i != 0)):
            (sample_imgs, aug_imgs, spy_imgs) = get_visual_samples(test_ds, model, test_num_samples, difficulty)
            sample_imgs = color_composite(sample_imgs)
            aug_imgs = color_composite(aug_imgs)
            if CFG['use_spy']:
                spy_imgs = color_composite(spy_imgs)
            (fig, axes) = (plt.subplots(3, 4) if CFG['use_spy'] else plt.subplots(2, 4))
            for img_i in range(4):
                axes[0][img_i].imshow(sample_imgs[img_i])
                axes[1][img_i].imshow(aug_imgs[img_i])
                if CFG['use_spy']:
                    axes[2][img_i].imshow(spy_imgs[img_i])
            if CFG['USE_GS']:
                gallery_dir = f"gallery/{CFG['run_name']}"
                img_name = os.path.join(gallery_dir, f'{e_i}.png')
                img_data = io.BytesIO()
                plt.savefig(img_data, format='png')
                img_data.seek(0)
                gs_upload_blob_from_memory(img_data, img_name)
            else:
                gallery_dir = f"{path_prefix}gallery/{CFG['run_name']}"
                os.makedirs(gallery_dir, exist_ok=True)
                img_name = os.path.join(gallery_dir, f'{e_i}.png')
                plt.savefig(img_name, format='png')
            plt.clf()
            plt.cla()
            plt.close()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    for  ...  in:
        if:
 = (plt.subplots if else)

idx = 17:------------------- similar code ------------------ index = 24, score = 6.0 
def plot(self, marker=''):
    (fig, ax) = plt.subplots()
    ax.set_aspect('equal')
    for state in self.trajectory:
        plt.plot(state[0], state[1], marker=marker, color='black')
    plt.gca().axes.xaxis.set_ticklabels([])
    plt.gca().axes.yaxis.set_ticklabels([])
    plt.xticks([])
    plt.yticks([])
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots()

idx = 18:------------------- similar code ------------------ index = 25, score = 6.0 
def plot_hex_grid(trajectory, shape=None, slice=(- 1), title='', colormap='Greys', vmin=None, vmax=None, edgecolor=None):
    activities = get_activities_over_time_as_list(trajectory)
    if (shape is not None):
        activities = np.array(activities).reshape((len(activities), shape[0], shape[1]))[slice]
    triples = _get_triples(activities)
    has_odd_rows = ((len(activities) % 2) != 0)
    (fig, ax) = plt.subplots(1)
    ax.set_aspect('equal')
    m = _get_scaled_colormap(triples, colormap, vmin, vmax)
    for t in triples:
        (x, y) = (_oddr_offset_to_pixel(t[0], t[1]) if has_odd_rows else _evenr_offset_to_pixel(t[0], t[1]))
        hex = RegularPolygon((x, y), numVertices=6, radius=1.0, orientation=np.radians(60), facecolor=m.to_rgba(t[2]), edgecolor=edgecolor)
        ax.add_patch(hex)
    ax.scatter([t[0] for t in triples], [t[1] for t in triples], marker='')
    plt.gca().invert_yaxis()
    plt.title(title)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots

idx = 19:------------------- similar code ------------------ index = 26, score = 6.0 
if (__name__ == '__main__'):
    import os
    os.environ['CUDA_DEVICE_ORDER'] = 'PCI_BUS_ID'
    os.environ['CUDA_VISIBLE_DEVICES'] = ''
    x = tf.random.normal((4, 100, 100, 3))
    x = (x - tf.math.reduce_min(x))
    x = (x / tf.math.reduce_max(x))
    x_aug = transform(x)
    (fig, axes) = plt.subplots(4, 2)
    for b in range(4):
        img = x[b]
        img_aug = x_aug[b]
        axes[b][0].imshow(img)
        axes[b][1].imshow(img_aug)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
if:
 = plt.subplots

idx = 20:------------------- similar code ------------------ index = 1, score = 6.0 
def plot1D(x, y, color=None, label=None, xlabel=None, ylabel=None, xlim=None, ylim=None, twinx=False, legend=None, tight_layout=None, title=None):
    '\n    Creates a 1D plot of the given x and y values.\n\n    :param x: A list representing the values of the x-axis.\n\n    :param y: A list representing the values of the y-axis. If the values of this list are also lists, then each will\n              be plotted as a separate series on the y-axis.\n\n    :param color: A string, representing the color of the series, or a list of colors, representing the color of each\n                   series to be plotted. The number of colors must match the number of series. The color values must\n                   be recognizable by Matplotlib.\n\n    :param label: A string or number, or a list of strings or numbers, representing the labels of each series to be\n                  plotted. The number of labels must match the number of series.\n\n    :param xlabel: A string representing the label of the x-axis.\n\n    :param ylabel: A string, or list of at most two strings, representing the label(s) of the y-axis.\n\n    :param xlim: A 2-tuple of numbers, representing the limits of the x-axis.\n\n    :param ylim: A 2-tuple of numbers, or a list of at most two 2-tuples of numbers, representing the\n                 limits of the y-axis.\n\n    :param twinx: If True, the provided y series will be plotted on two separate y-axes, and there must\n                  be at least two series of y values provided. If there are more than two series of y values,\n                  then each series will be plotted on alternating y-axes. (Default is False)\n\n    :param legend: A dict, or a list of at most two dicts, representing the arguments to the legend\n                   function of Matplotlib.\n\n    :param tight_layout: A dict representing the arguments to the tight_layout function of Matplotlib.\n\n    :param title: The plot title.\n    '
    axes = []
    (fig, ax1) = plt.subplots()
    axes.append(ax1)
    if twinx:
        axes.append(ax1.twinx())
        if (len(y) < 2):
            raise Exception('there must be at least two series of y values provided')
        for _y in y:
            if (not isinstance(_y, (list, np.ndarray))):
                raise Exception('an item in y must be a list representing a y series')
    current_axis_idx = 0
    is_multiseries = isinstance(y[0], (list, np.ndarray))

    def _get_item(items, i):
        if isinstance(items, str):
            return items
        if isinstance(items, collections.Sequence):
            return items[i]
        return items
    if (not is_multiseries):
        y = [y]
    for (i, y_series) in enumerate(y):
        current_axis = axes[(current_axis_idx % len(axes))]
        plot_args = {}
        if label:
            plot_args['label'] = _get_item(label, i)
        if color:
            plot_args['color'] = _get_item(color, i)
        current_axis.plot(x, y_series, **plot_args)
        if xlabel:
            current_axis.set_xlabel(xlabel)
        if ylabel:
            ylabel_args = {}
            if color:
                ylabel_args['color'] = _get_item(color, i)
            current_axis.set_ylabel(_get_item(ylabel, (i % 2)), **ylabel_args)
        if xlim:
            current_axis.set_xlim(xlim)
        if ylim:
            current_axis.set_ylim(_get_item(ylim, (i % 2)))
        if legend:
            current_axis.legend(**legend)
        current_axis_idx += 1
    if tight_layout:
        plt.tight_layout(**tight_layout)
    if title:
        plt.title(title)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots()

idx = 21:------------------- similar code ------------------ index = 28, score = 6.0 
def run(device, show_plots, process_data=None, **get_data_kwargs):
    with NumpySeed(100):
        data = get_data(**get_data_kwargs)
        if (process_data is None):
            process_data = (lambda *x: x)
        (sprites, scales, offsets, backgrounds) = process_data(*data)
        with tf.device('/{}:0'.format(device)):
            images = render_sprites.render_sprites(sprites, scales, offsets, backgrounds)
            sess = get_session()
            result = sess.run(images)
        result = np.clip(result, 1e-06, (1 - 1e-06))
    if show_plots:
        import matplotlib.pyplot as plt
        (fig, (ax1, ax2)) = plt.subplots(1, 2)
        ax1.imshow(result[0])
        ax2.imshow(result[1])
        plt.show()

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    if  ... :
 = plt.subplots

idx = 22:------------------- similar code ------------------ index = 7, score = 6.0 
def animate_network(trajectory, save=False, interval=50, dpi=80, layout='shell', with_labels=True, with_arrows=True, node_color='b', node_size=30, with_timestep=False, show=True):
    (fig, ax) = plt.subplots()

    def update(arg):
        ax.clear()
        (i, state) = arg
        if with_timestep:
            ax.set_title(('timestep: %s' % (i + 1)))
        color = (node_color[i] if (type(node_color) == dict) else node_color)
        network = state.network
        G = nx.MultiDiGraph()
        for n in network.nodes:
            G.add_node(n)
        for edge in network.edges:
            G.add_edge(edge[0], edge[1])
        state_layout = (layout[i] if ((type(layout) == list) or (type(layout) == tuple)) else layout)
        if (state_layout == 'shell'):
            nx.draw_shell(G, with_labels=with_labels, node_color=color, node_size=node_size, arrows=with_arrows)
        elif (state_layout == 'spring'):
            nx.draw_spring(G, with_labels=with_labels, node_color=color, node_size=node_size, arrows=with_arrows)
        elif (state_layout == 'planar'):
            nx.draw_planar(G, with_labels=with_labels, node_color=color, node_size=node_size, arrows=with_arrows)
        elif (state_layout == 'kamada-kawai'):
            nx.draw_kamada_kawai(G, with_labels=with_labels, node_color=color, node_size=node_size, arrows=with_arrows)
        elif isinstance(state_layout, dict):
            nx.draw(G, pos=state_layout, with_labels=with_labels, node_color=color, node_size=node_size, arrows=with_arrows)
        else:
            raise Exception(('unsupported layout: %s' % state_layout))
    ani = animation.FuncAnimation(fig, update, frames=list(enumerate(trajectory)), interval=interval, save_count=len(trajectory))
    if save:
        ani.save('evolved.gif', dpi=dpi, writer='imagemagick')
    if show:
        plt.show()
    return ani

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
 = plt.subplots()


idx = 23:------------------- similar code ------------------ index = 6, score = 5.0 
def plot_pdos(self, ax: Optional[Axes]=None, to_plot: Optional[Dict[(str, List[str])]]=None, colors: Optional[Iterable]=None, plot_total_dos: Optional[bool]=True, xrange: Optional[Tuple[(float, float)]]=None, ymax: Optional[float]=None, scaling: Optional[Dict[(str, Dict[(str, float)])]]=None, split: bool=False, title: Optional[str]=None, title_loc: str='center', labels: bool=True, title_fontsize: int=16, legend_pos: str='outside') -> Figure:
    if (not ax):
        (fig, ax) = plt.subplots(1, 1, figsize=(8.0, 3.0))
    else:
        fig = None
    if (not colors):
        colors = mcd.TABLEAU_COLORS
    assert isinstance(colors, Iterable)
    color_iterator = (c for c in colors)
    if (not scaling):
        scaling = {}
    if xrange:
        e_range = ((self.energy >= xrange[0]) & (self.energy <= xrange[1]))
    else:
        e_range = np.ma.make_mask(self.energy)
    auto_ymax = 0.0
    if (not to_plot):
        to_plot = {}
        assert isinstance(self.species, Iterable)
        for s in set(self.species):
            to_plot[s] = ['s', 'p', 'd']
            if (self.lmax == 3):
                to_plot[s].append('f')
    for species in to_plot.keys():
        assert isinstance(self.species, Iterable)
        index = [i for (i, s) in enumerate(self.species) if (s == species)]
        for state in to_plot[species]:
            assert (state in ['s', 'p', 'd', 'f'])
            color = next(color_iterator)
            label = '{} {}'.format(species, state)
            up_dos = self.pdos_sum(atoms=index, l=state, spin='up')[e_range]
            down_dos = self.pdos_sum(atoms=index, l=state, spin='down')[e_range]
            if (species in scaling):
                if (state in scaling[species]):
                    up_dos *= scaling[species][state]
                    down_dos *= scaling[species][state]
                    label = '{} {} $\\times${}'.format(species, state, scaling[species][state])
            auto_ymax = max([auto_ymax, up_dos.max(), down_dos.max()])
            ax.plot(self.energy[e_range], up_dos, label=label, c=color)
            ax.plot(self.energy[e_range], (down_dos * (- 1.0)), c=color)
    if plot_total_dos:
        ax.fill_between(self.energy[e_range], self.tdos.up.values[e_range], (self.tdos.down.values[e_range] * (- 1.0)), facecolor=TABLEAU_GREY, alpha=0.2)
        auto_ymax = max([auto_ymax, self.tdos.up.values[e_range].max(), self.tdos.down.values[e_range].max()])
    if xrange:
        ax.set_xlim(xrange[0], xrange[1])
    if (not ymax):
        ymax = (1.1 * auto_ymax)
    ax.set_ylim(((- ymax) * 1.1), (ymax * 1.1))
    if (legend_pos == 'outside'):
        ax.legend(bbox_to_anchor=(1.01, 1.04), loc='upper left')
    else:
        ax.legend(loc=legend_pos)
    if labels:
        ax.set_xlabel('Energy [eV]')
    ax.axhline(y=0, c='lightgrey')
    ax.axes.grid(False, axis='y')
    ax.tick_params(axis='y', which='both', left=False, right=False, labelleft=False)
    if title:
        ax.set_title(title, loc=title_loc, fontdict={'fontsize': title_fontsize})
    return fig

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... () ->  ... :
    if:
 = plt.subplots

idx = 24:------------------- similar code ------------------ index = 15, score = 5.0 
def plot_degree_mrr(node_ranks):
    degree_rank = {}
    for (node, rank) in node_ranks.items():
        node_degree = node.get_degree()
        if (node_degree not in degree_rank):
            degree_rank[node_degree] = []
        degree_rank[node_degree].append((sum(rank) / len(rank)))
    degrees = []
    ranks = []
    for k in sorted(degree_rank.keys()):
        if (k < 20):
            for rank in degree_rank[k]:
                if (rank < 100):
                    degrees.append(k)
                    ranks.append(rank)
    (fig, ax) = plt.subplots()
    ax.scatter(degrees, ranks, marker='.')
    ax.set(xlabel='degree', ylabel='mean ranks')
    ax.grid()
    fig.savefig('comet_cn_degree_ranks.png')

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ( ... ):
 = plt.subplots()

idx = 25:------------------- similar code ------------------ index = 27, score = 5.0 
def plot_dielectric_functions(dielectric, ax=None):
    real_dielectric = parse_dielectric_data(dielectric[1])
    imag_dielectric = parse_dielectric_data(dielectric[2])
    if (ax is None):
        (fig, ax) = plt.subplots(1, 1, figsize=(6.0, 3.0))
    else:
        fig = None
    ax.plot(dielectric[0], np.mean(real_dielectric, axis=1), '-', zorder=2)
    ax.plot(dielectric[0], np.mean(imag_dielectric, axis=1), '-', zorder=2)
    ax.set_xlim([0, 8])
    ax.set_ylim([0, 5])
    return fig

------------------- similar code (pruned) ------------------ score = 0.46153846153846156 
def  ... ():
    if:
 = plt.subplots

idx = 26:------------------- similar code ------------------ index = 12, score = 3.0 
def plot_addition_old(extension):
    yolo_path = os.path.join(data_dir, 'addition/2stage/run_search_sample_complexity_experiment_yolo_air_VS_nips_2018_addition_14x14_kind=long_cedar_seed=0_2018_05_14_03_04_29')
    yolo_supplement_path = os.path.join(data_dir, 'addition/2stage/run_search_supplement_sample_complexity_experiment_yolo_air_VS_nips_2018_addition_14x14_kind=supplement_seed=0_2018_05_14_14_18_26')
    simple_path = os.path.join(data_dir, 'addition/simple/run_search_sample_complexity-size=14_colour=False_task=addition_alg=yolo_math_simple_duration=long_seed=0_2018_05_14_23_59_50')
    simple_2stage_path = os.path.join(data_dir, 'addition/simple_2stage/run_search_sample_complexity-size=14_colour=False_task=addition_alg=yolo_math_simple_2stage_duration=long_seed=0_2018_05_15_12_55_38')
    fig = plt.figure(figsize=(5, 3.5))
    ax = plt.gca()
    measure = 'math_accuracy'
    (x, y, *yerr) = get_arithmetic_data([yolo_path, yolo_supplement_path], 'n_train', measure, 1, 'ci95')
    label = 'SI-AIR'
    ax.errorbar(x, y, yerr=yerr, label=label)
    (x, y, *yerr) = get_arithmetic_data([simple_path], 'n_train', measure, 0, 'ci95')
    label = 'Conv'
    ax.errorbar(x, y, yerr=yerr, label=label)
    (x, y, *yerr) = get_arithmetic_data([simple_2stage_path], 'n_train', measure, 0, 'ci95')
    label = 'Conv - 2stage'
    ax.errorbar(x, y, yerr=yerr, label=label)
    ax.set_ylabel('Accuracy', fontsize=12)
    ax.set_xlabel('\\# Training Samples / 1000', fontsize=12)
    ax.set_title('Addition - Between 1 and 11 numbers', fontsize=12)
    ax.tick_params(axis='both', labelsize=14)
    ax.set_ylim((0.0, 1.05))
    ax.set_xticks(x)
    ax.set_xticklabels((np.array(x) / 1000).astype('i'))
    plt.legend(loc='upper left')
    plot_path = os.path.join(plot_dir, ('addition/main.' + extension))
    os.makedirs(os.path.dirname(plot_path), exist_ok=True)
    plt.subplots_adjust(left=0.12, bottom=0.14, right=0.98, top=0.91)
    fig.savefig(plot_path)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.3 
def  ... ( ... ):
    plt

idx = 27:------------------- similar code ------------------ index = 13, score = 3.0 
def plot_addition(extension):
    air_fixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=fixed_alg=air-math_duration=long_seed=0_2018_07_29_09_58_58/')
    baseline_fixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=fixed_alg=baseline-math_duration=long_seed=0_2018_07_28_22_01_21/')
    ground_truth_fixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=fixed_alg=ground-truth-math_duration=long_seed=0_2018_07_28_22_02_14/')
    simple_fixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=fixed_alg=simple-math_duration=long_seed=0_2018_07_28_22_03_18/')
    yolo_air_fixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=fixed_alg=yolo-air-math_duration=long_seed=0_2018_07_28_22_04_04/')
    baseline_raw_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=raw_alg=baseline-math_duration=long_seed=0_2018_07_28_22_00_58/')
    ground_truth_raw_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=raw_alg=ground-truth-math_duration=long_seed=0_2018_07_28_22_01_56/')
    simple_raw_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=raw_alg=simple-math_duration=long_seed=0_2018_07_28_22_02_59/')
    air_unfixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=unfixed_alg=air-math_duration=long_seed=0_2018_07_29_09_58_32/')
    baseline_unfixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=unfixed_alg=baseline-math_duration=long_seed=0_2018_07_28_22_01_39/')
    ground_truth_unfixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=unfixed_alg=ground-truth-math_duration=long_seed=0_2018_07_28_22_02_30/')
    simple_unfixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=unfixed_alg=simple-math_duration=long_seed=0_2018_07_28_22_03_41/')
    yolo_air_unfixed_path = os.path.join(data_dir, 'addition/stage2/run_search_addition-stage2_env=task=arithmetic2_run-kind=unfixed_alg=yolo-air-math_duration=long_seed=0_2018_07_28_22_04_21/')
    fig = plt.figure(figsize=(5, 4.5))
    ax = plt.gca()
    (x, y, *yerr) = get_arithmetic_data([baseline_raw_path], 'n_train', '_test_math_accuracy', 0, 'ci95')
    line = ax.errorbar(x, y, yerr=yerr, label='ConnComp', marker='o', ls='-')
    (x, y, *yerr) = get_arithmetic_data([ground_truth_raw_path], 'n_train', '_test_math_accuracy', 0, 'ci95')
    line = ax.errorbar(x, y, yerr=yerr, label='TrueBB', marker='^', ls='-')
    (x, y, *yerr) = get_arithmetic_data([simple_raw_path], 'n_train', '_test_math_accuracy', 0, 'ci95')
    line = ax.errorbar(x, y, yerr=yerr, label='ConvNet', marker='v', ls='-')
    (x, y, *yerr) = get_arithmetic_data([yolo_air_fixed_path], 'n_train', '_test_math_accuracy', 0, 'ci95')
    line = ax.errorbar(x, y, yerr=yerr, label='SPAIR - Fixed', marker='v', ls='-')
    yolo_air_color = line.lines[0].get_c()
    (x, y, *yerr) = get_arithmetic_data([yolo_air_unfixed_path], 'n_train', '_test_math_accuracy', 0, 'ci95')
    line = ax.errorbar(x, y, yerr=yerr, label='SPAIR - Unfixed', marker='v', ls='--', color=yolo_air_color)
    (x, y, *yerr) = get_arithmetic_data([air_fixed_path], 'n_train', '_test_math_accuracy', 0, 'ci95')
    line = ax.errorbar(x, y, yerr=yerr, label='AIR - Fixed', marker='o', ls='-')
    air_color = line.lines[0].get_c()
    (x, y, *yerr) = get_arithmetic_data([air_unfixed_path], 'n_train', '_test_math_accuracy', 0, 'ci95')
    line = ax.errorbar(x, y, yerr=yerr, label='AIR - Unfixed', marker='o', ls='--', color=air_color)
    ax.set_ylabel('Accuracy')
    ax.set_xlabel('\\# Training Examples / 1000')
    ax.tick_params(axis='both')
    ax.set_ylim((0.0, 1.05))
    ax.set_xscale('log')
    ax.set_xticks(x)
    ax.set_xticklabels((np.array(x) / 1000).astype('i'))
    plt.legend(loc='lower center', handlelength=2.5, bbox_to_anchor=(0.5, 1.01), ncol=3, columnspacing=1)
    plt.subplots_adjust(left=0.1, bottom=0.1, right=0.99, top=0.82)
    plot_path = os.path.join(plot_dir, ('addition/main.' + extension))
    os.makedirs(os.path.dirname(plot_path), exist_ok=True)
    fig.savefig(plot_path)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.3 
def  ... ( ... ):
    plt

idx = 28:------------------- similar code ------------------ index = 17, score = 3.0 
def plot_comparison(extension):
    yolo_air_path = os.path.join(data_dir, 'comparison/run_search_yolo-air-run_env=size=14-in-colour=False-task=arithmetic-ops=addition_alg=yolo-air_duration=long_seed=0_2018_07_16_13_46_48/')
    air_path = os.path.join(data_dir, 'comparison/run_search_air-run_env=size=14-in-colour=False-task=arithmetic-ops=addition_alg=attend-infer-repeat_duration=long_seed=0_2018_07_24_13_02_34')
    dair_path = os.path.join(data_dir, 'comparison/run_search_dair-run_env=size=14-in-colour=False-task=arithmetic-ops=addition_alg=attend-infer-repeat_duration=long_seed=0_2018_07_10_09_22_24')
    baseline_path = os.path.join(data_dir, 'comparison/run_search_comparison-baseline_env=size=14-in-colour=False-task=arithmetic-ops=addition_alg=baseline_duration=oak_seed=0_2018_07_20_11_15_24/')
    fig = plt.figure(figsize=(5, 3.5))
    ax = plt.gca()
    y_func = (lambda y: (100 * y))
    (x, y, *yerr) = get_arithmetic_data([yolo_air_path], 'n_digits', '_test_AP', 0, 'ci95', y_func=y_func)
    line = ax.errorbar(x, y, yerr=yerr, label='SPAIR', marker='o', ls='-')
    line.lines[0].get_c()
    (x, y, *yerr) = get_arithmetic_data([air_path], 'n_digits', '_test_AP', 0, 'ci95', y_func=y_func)
    line = ax.errorbar(x, y, yerr=yerr, label='AIR', marker='^', ls='-.')
    line.lines[0].get_c()
    (x, y, *yerr) = get_arithmetic_data([dair_path], 'n_digits', 'AP', 0, 'ci95', y_func=y_func)
    line = ax.errorbar(x, y, yerr=yerr, label='DAIR', marker='v', ls='--')
    line.lines[0].get_c()
    (x, y, *yerr) = get_arithmetic_data([baseline_path], 'n_digits', '_test_AP', 0, 'ci95', y_func=y_func)
    ax.plot(x, y, label='ConnComp', marker='s', ls=':')
    ax.set_ylabel('Average Precision', fontsize=12)
    ax.set_xlabel('\\# Digits in Image', fontsize=12)
    ax.tick_params(axis='both', labelsize=14)
    ax.set_ylim((0.0, 105.0))
    ax.set_xticks(x)
    plt.legend(loc='upper right', handlelength=4)
    plt.subplots_adjust(left=0.12, bottom=0.13, right=0.99, top=0.99)
    plot_path = os.path.join(plot_dir, ('comparison/main.' + extension))
    os.makedirs(os.path.dirname(plot_path), exist_ok=True)
    fig.savefig(plot_path)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.3 
def  ... ( ... ):
    plt

idx = 29:------------------- similar code ------------------ index = 23, score = 3.0 
def _plot_reconstruction(self, updater, fetched):
    inp = fetched['inp']
    output = fetched['output']
    (_, image_height, image_width, _) = inp.shape
    obj = fetched['obj'].reshape(self.N, (- 1))
    anchor_box = updater.network.anchor_box
    (yt, xt, ys, xs) = np.split(fetched['normalized_box'], 4, axis=(- 1))
    (yt, xt, ys, xs) = coords_to_pixel_space(yt, xt, ys, xs, (image_height, image_width), anchor_box, top_left=True)
    box = np.concatenate([yt, xt, ys, xs], axis=(- 1))
    box = box.reshape(self.N, (- 1), 4)
    on_colour = np.array(to_rgb('xkcd:azure'))
    off_colour = np.array(to_rgb('xkcd:red'))
    for (n, (pred, gt)) in enumerate(zip(output, inp)):
        fig = plt.figure(figsize=(5, 5))
        ax = plt.gca()
        self.imshow(ax, gt)
        ax.set_axis_off()
        for (o, (top, left, height, width)) in zip(obj[n], box[n]):
            if ((not self.show_zero_boxes) and (o <= 1e-06)):
                continue
            colour = ((o * on_colour) + ((1 - o) * off_colour))
            rect = patches.Rectangle((left, top), width, height, linewidth=2, edgecolor=colour, facecolor='none')
            ax.add_patch(rect)
        plt.subplots_adjust(left=0.01, right=0.99, top=0.99, bottom=0.01, wspace=0.1, hspace=0.1)
        self.savefig(('ground_truth/' + str(n)), fig, updater, is_dir=False)

------------------- similar code (pruned) ------------------ score = 0.3 
def  ... ():
    for in:
        plt

idx = 30:------------------- similar code ------------------ index = 0, score = 3.0 
def plot_arithmetic(extension):
    yolo_path = os.path.join(data_dir, 'arithmetic/2stage/run_search_sample_complexity-size=14_colour=False_task=arithmetic_alg=yolo_math_2stage_duration=long_seed=0_2018_05_15_00_32_28')
    simple_path = os.path.join(data_dir, 'arithmetic/simple/run_search_sample_complexity-size=14_colour=False_task=arithmetic_alg=yolo_math_simple_duration=long_seed=0_2018_05_15_00_01_16')
    simple_2stage_path = os.path.join(data_dir, 'arithmetic/simple_2stage/run_search_sample_complexity-size=14_colour=False_task=arithmetic_alg=yolo_math_simple_2stage_duration=long_seed=0_2018_05_15_12_59_19')
    fig = plt.figure(figsize=(5, 3.5))
    ax = plt.gca()
    measure = 'math_accuracy'
    (x, y, *yerr) = get_arithmetic_data([yolo_path], 'n_train', measure, 1, 'ci95')
    label = 'SI-AIR'
    ax.errorbar(x, y, yerr=yerr, label=label)
    (x, y, *yerr) = get_arithmetic_data([simple_path], 'n_train', measure, 0, 'ci95')
    label = 'Conv'
    ax.errorbar(x, y, yerr=yerr, label=label)
    (x, y, *yerr) = get_arithmetic_data([simple_2stage_path], 'n_train', measure, 0, 'ci95')
    label = 'Conv - 2stage'
    ax.errorbar(x, y, yerr=yerr, label=label)
    ax.set_ylabel('Accuracy', fontsize=12)
    ax.set_xlabel('# Training Samples / 1000', fontsize=12)
    ax.set_title('Arithmetic - Between 1 and 11 numbers', fontsize=12)
    ax.tick_params(axis='both', labelsize=14)
    ax.set_ylim((0.0, 1.05))
    ax.set_xticks(x)
    ax.set_xticklabels((np.array(x) / 1000).astype('i'))
    plt.legend(loc='upper left')
    plot_path = os.path.join(plot_dir, ('arithmetic/main.' + extension))
    os.makedirs(os.path.dirname(plot_path), exist_ok=True)
    plt.subplots_adjust(left=0.12, bottom=0.14, right=0.98, top=0.91)
    fig.savefig(plot_path)
    plt.show()

------------------- similar code (pruned) ------------------ score = 0.3 
def  ... ( ... ):
    plt

