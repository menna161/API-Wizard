import os
import numpy as np
import torch
import random
import time
import numba as nb
import yaml
from torch.utils import data


@nb.jit('u1[:,:,:](u1[:,:,:],i8[:,:])', nopython=True, cache=True, parallel=False)
def nb_process_label(processed_label, sorted_label_voxel_pair):
    label_size = 256
    counter = np.zeros((label_size,), dtype=np.uint16)
    counter[sorted_label_voxel_pair[(0, 3)]] = 1
    cur_sear_ind = sorted_label_voxel_pair[(0, :3)]
    for i in range(1, sorted_label_voxel_pair.shape[0]):
        cur_ind = sorted_label_voxel_pair[(i, :3)]
        if (not np.all(np.equal(cur_ind, cur_sear_ind))):
            processed_label[(cur_sear_ind[0], cur_sear_ind[1], cur_sear_ind[2])] = np.argmax(counter)
            counter = np.zeros((label_size,), dtype=np.uint16)
            cur_sear_ind = cur_ind
        counter[sorted_label_voxel_pair[(i, 3)]] += 1
    processed_label[(cur_sear_ind[0], cur_sear_ind[1], cur_sear_ind[2])] = np.argmax(counter)
    return processed_label
